<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ng_mk_geometric_models</title>
  <meta name="keywords" content="ng_mk_geometric_models">
  <meta name="description" content="NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">meshing</a> &gt; <a href="index.html">netgen</a> &gt; ng_mk_geometric_models.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/meshing/netgen&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>ng_mk_geometric_models
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body
 and electrodes are defined as combinations of solid primitives. The 3-D
 surface intersection of the electrode and body volumes define the
 electrode surfaces.

[fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)

 INPUT:
  body_geometry      - Structure whose fields describe body geometries as
                       combinations of unions, intersections and 
                       complements of solid primitives. Cell array
                       should be used when describing several body 
                       geometries.

  electrode_geometry - Structure whose fields describe electrode
                       geometries as combinations of unions, intersections
                       and complements of solid primitives. Cell array
                       should be used when describing several electrode 
                       geometries.

 The following field names are available for geometry descriptions. Each 
 field is followed by the available subfields whose default values if left 
 unspecified are indicated between parentheses. 

 complement_flag:    If true, the desired geometry description is the
                     complement of the geometry description. (false)

 body_of_revolution: A body of revolution is described with the following
                     subfields: axis_point_a ([0; 0; 0]), axis_point_b 
                     ([0; 0; 1]), points (1 1; 1 2; 2 2; 2 1]),
                     segments ([1 2; 2 3; 3 4; 4 1]), complement_flag
                     (false).    

 cone:               A cone is described with the following subfields:
                     bottom_center ([0; 0; 0]), bottom_radius (1),
                     top_center ([0; 0; 1]), top_radius (0.5),
                     complement_flag (false).                    

 cylinder:           A cylinder is described with the following subfields:
                     bottom_center ([0; 0; 0]), top_center ([0; 0; 1]),
                     radius (1), complement_flag (false).

 ellipsoid:          An ellipsoid is described with the following
                     subfields: center ([0; 0; 0]), axis_a ([1; 0; 0]),
                     axis_b ([0; 1; 0]), axis_c ([0; 0; 1]),
                     complement_flag (false).

 elliptic_cylinder:  An elliptic cylinder is described with the following
                     subfields: bottom_center ([0; 0; 0]),
                     top_center ([0; 0; 1]), axis_a ([1; 0; 0]),
                     axis_b ([0; 1; 0]), complement_flag (false). 

 enter_body_flag:    This flag can be used only for electrode geometry
                     descriptions to indicate that the associated
                     electrode solid enters the body solids. It can only
                     be defined at the top level of each geometry
                     description. If this flag is true, it means that the
                     volume of the electrode intersecting with any body is
                     part of the electrode, otherwise it is part of a
                     body. (false)

 half_space          A half-space is described by the following subfields:
                     point ([0; 0; 0]), outward_normal_vector ([0; 0; 1]),
                     complement_flag (false).

 intersection:       This fields indicates to perform the intersection of
                     all subfields. Subfields: complement_flag (false).

 keep_material_flag: This flag can be used only for electrode geometry 
                     descriptions to indicate that the associated
                     electrode material should be kept in the final mesh.
                     It can only be defined at the top level of each
                     geometry description. If true, it means that the
                     volume of the electrode is meshed. Volume elements
                     that are part of the mesh are indicated in mat_idx
                     output argument. (false)

 max_edge_length:    This parameter is used to adjust the maximum size of
                     the element composing the mesh. It can only be used
                     at the top level of each geometry description. (inf)

 name:               This parameter is used to name the geometry
                     description.

 ortho_brick:        An ortho-brick is described by the following
                     subfields: opposite_corner_a ([0; 0; 0]),
                     opposite_corner_b ([1; 1; 1]), complement_flag
                     (false).

 parallelepiped:     A parallelepiped is described by the following
                     subfields: vertex ([0; 0; 0]), vector_a ([1; 0; 0]),
                     vector_b ([0; 1; 0]), vector_c ([0; 0; 1]),
                     complement_flag (false).

 point:              This parameter describes a point. It can only be used
                     at the top level of an electrode geometry
                     description. It must be the only field in the
                     structure. ([])

 sphere:             A sphere is described with the following subfields:
                     center ([0; 0; 0]), radius (1), complement_flag
                     (false).

 union:              This will perform the union of all its subfields.
                     There is an implicit union operator at the top level
                     of the geometry structure. Subfields: complement_flag
                     (false)

 OUTPUT:
  fmdl               - EIDORS forward model object.

  mat_idx            - Vector indicating for each mesh element the indices
                       of materials corresponding as separately defined
                       by input argument body_geometry.

 USAGE EXAMPLES:
 % 3D cylinder with radius 1. One plane of 16 electrodes with radius 0.1
   body_geometry.cylinder = struct;
   n_elect = 16;
   theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
   for i = 1:n_elect
     electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
     electrode_geometry{i}.sphere.radius = 0.1;
   end
   fmdl = ng_mk_geometric_models(body_geometry, electrode_geometry);</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>	CALL_NETGEN: call netgen to create a vol_file from a geo_file</li><li><a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>	NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>	NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</li><li><a href="../../../eidors/meshing/ng_mk_common_model.html" class="code" title="function fmdl = ng_mk_common_model(mdl_type,mdl_shape, elec_pos, elec_shape);">ng_mk_common_model</a>	NG_MK_COMMON_MODEL: utility to create common models</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [fmdl_mat_idx] = mk_geometric_models(body_geometry, electrode_geometry)</a></li><li><a href="#_sub2" class="code">function radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub3" class="code">function point = assign_point(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub4" class="code">function point_list = assign_list_of_3D_points(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub5" class="code">function segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub6" class="code">function segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub7" class="code">function flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)</a></li><li><a href="#_sub8" class="code">function [extra_code extra_param] = parse_geometry_point(geometry)</a></li><li><a href="#_sub9" class="code">function [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)</a></li><li><a href="#_sub10" class="code">function [geo_code extra_code] = parse_geometry_body_of_extrusion(body_of_extrusion, operator_string)</a></li><li><a href="#_sub11" class="code">function [geo_code extra_code] = parse_geometry_body_of_revolution(body_of_revolution, operator_string)</a></li><li><a href="#_sub12" class="code">function geo_code = parse_geometry_cone(cone, operator_string)</a></li><li><a href="#_sub13" class="code">function geo_code = parse_geometry_cylinder(cylinder, operator_string)</a></li><li><a href="#_sub14" class="code">function geo_code = parse_geometry_ellipsoid(ellipsoid, operator_string)</a></li><li><a href="#_sub15" class="code">function geo_code = parse_geometry_elliptic_cylinder(elliptic_cylinder, operator_string)</a></li><li><a href="#_sub16" class="code">function geo_code = parse_geometry_half_space(half_space, operator_string)</a></li><li><a href="#_sub17" class="code">function geo_code = parse_geometry_ortho_brick(ortho_brick, operator_string)</a></li><li><a href="#_sub18" class="code">function geo_code = parse_geometry_parallelepiped(parallelepiped, operator_string)</a></li><li><a href="#_sub19" class="code">function geo_code = parse_geometry_sphere(sphere, operator_string)</a></li><li><a href="#_sub20" class="code">function write_geo_file(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param)</a></li><li><a href="#_sub21" class="code">function mat = read_mat_from_file(fid, nrows, ncols)</a></li><li><a href="#_sub22" class="code">function fmdl = read_vol_file(vol_fn, electrode_extra_param)</a></li><li><a href="#_sub23" class="code">function fmdl = complete_fmdl(fmdl, electrode_extra_param)</a></li><li><a href="#_sub24" class="code">function do_unit_test</a></li><li><a href="#_sub25" class="code">function [fmdl, opts] = do_test_number(tn)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)</a>
0002 <span class="comment">% NG_MK_GEOMETRIC_MODELS: create geometric mesh models using Netgen. Body</span>
0003 <span class="comment">% and electrodes are defined as combinations of solid primitives. The 3-D</span>
0004 <span class="comment">% surface intersection of the electrode and body volumes define the</span>
0005 <span class="comment">% electrode surfaces.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%[fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% INPUT:</span>
0010 <span class="comment">%  body_geometry      - Structure whose fields describe body geometries as</span>
0011 <span class="comment">%                       combinations of unions, intersections and</span>
0012 <span class="comment">%                       complements of solid primitives. Cell array</span>
0013 <span class="comment">%                       should be used when describing several body</span>
0014 <span class="comment">%                       geometries.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%  electrode_geometry - Structure whose fields describe electrode</span>
0017 <span class="comment">%                       geometries as combinations of unions, intersections</span>
0018 <span class="comment">%                       and complements of solid primitives. Cell array</span>
0019 <span class="comment">%                       should be used when describing several electrode</span>
0020 <span class="comment">%                       geometries.</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% The following field names are available for geometry descriptions. Each</span>
0023 <span class="comment">% field is followed by the available subfields whose default values if left</span>
0024 <span class="comment">% unspecified are indicated between parentheses.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">% complement_flag:    If true, the desired geometry description is the</span>
0027 <span class="comment">%                     complement of the geometry description. (false)</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% body_of_revolution: A body of revolution is described with the following</span>
0030 <span class="comment">%                     subfields: axis_point_a ([0; 0; 0]), axis_point_b</span>
0031 <span class="comment">%                     ([0; 0; 1]), points (1 1; 1 2; 2 2; 2 1]),</span>
0032 <span class="comment">%                     segments ([1 2; 2 3; 3 4; 4 1]), complement_flag</span>
0033 <span class="comment">%                     (false).</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% cone:               A cone is described with the following subfields:</span>
0036 <span class="comment">%                     bottom_center ([0; 0; 0]), bottom_radius (1),</span>
0037 <span class="comment">%                     top_center ([0; 0; 1]), top_radius (0.5),</span>
0038 <span class="comment">%                     complement_flag (false).</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% cylinder:           A cylinder is described with the following subfields:</span>
0041 <span class="comment">%                     bottom_center ([0; 0; 0]), top_center ([0; 0; 1]),</span>
0042 <span class="comment">%                     radius (1), complement_flag (false).</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% ellipsoid:          An ellipsoid is described with the following</span>
0045 <span class="comment">%                     subfields: center ([0; 0; 0]), axis_a ([1; 0; 0]),</span>
0046 <span class="comment">%                     axis_b ([0; 1; 0]), axis_c ([0; 0; 1]),</span>
0047 <span class="comment">%                     complement_flag (false).</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% elliptic_cylinder:  An elliptic cylinder is described with the following</span>
0050 <span class="comment">%                     subfields: bottom_center ([0; 0; 0]),</span>
0051 <span class="comment">%                     top_center ([0; 0; 1]), axis_a ([1; 0; 0]),</span>
0052 <span class="comment">%                     axis_b ([0; 1; 0]), complement_flag (false).</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% enter_body_flag:    This flag can be used only for electrode geometry</span>
0055 <span class="comment">%                     descriptions to indicate that the associated</span>
0056 <span class="comment">%                     electrode solid enters the body solids. It can only</span>
0057 <span class="comment">%                     be defined at the top level of each geometry</span>
0058 <span class="comment">%                     description. If this flag is true, it means that the</span>
0059 <span class="comment">%                     volume of the electrode intersecting with any body is</span>
0060 <span class="comment">%                     part of the electrode, otherwise it is part of a</span>
0061 <span class="comment">%                     body. (false)</span>
0062 <span class="comment">%</span>
0063 <span class="comment">% half_space          A half-space is described by the following subfields:</span>
0064 <span class="comment">%                     point ([0; 0; 0]), outward_normal_vector ([0; 0; 1]),</span>
0065 <span class="comment">%                     complement_flag (false).</span>
0066 <span class="comment">%</span>
0067 <span class="comment">% intersection:       This fields indicates to perform the intersection of</span>
0068 <span class="comment">%                     all subfields. Subfields: complement_flag (false).</span>
0069 <span class="comment">%</span>
0070 <span class="comment">% keep_material_flag: This flag can be used only for electrode geometry</span>
0071 <span class="comment">%                     descriptions to indicate that the associated</span>
0072 <span class="comment">%                     electrode material should be kept in the final mesh.</span>
0073 <span class="comment">%                     It can only be defined at the top level of each</span>
0074 <span class="comment">%                     geometry description. If true, it means that the</span>
0075 <span class="comment">%                     volume of the electrode is meshed. Volume elements</span>
0076 <span class="comment">%                     that are part of the mesh are indicated in mat_idx</span>
0077 <span class="comment">%                     output argument. (false)</span>
0078 <span class="comment">%</span>
0079 <span class="comment">% max_edge_length:    This parameter is used to adjust the maximum size of</span>
0080 <span class="comment">%                     the element composing the mesh. It can only be used</span>
0081 <span class="comment">%                     at the top level of each geometry description. (inf)</span>
0082 <span class="comment">%</span>
0083 <span class="comment">% name:               This parameter is used to name the geometry</span>
0084 <span class="comment">%                     description.</span>
0085 <span class="comment">%</span>
0086 <span class="comment">% ortho_brick:        An ortho-brick is described by the following</span>
0087 <span class="comment">%                     subfields: opposite_corner_a ([0; 0; 0]),</span>
0088 <span class="comment">%                     opposite_corner_b ([1; 1; 1]), complement_flag</span>
0089 <span class="comment">%                     (false).</span>
0090 <span class="comment">%</span>
0091 <span class="comment">% parallelepiped:     A parallelepiped is described by the following</span>
0092 <span class="comment">%                     subfields: vertex ([0; 0; 0]), vector_a ([1; 0; 0]),</span>
0093 <span class="comment">%                     vector_b ([0; 1; 0]), vector_c ([0; 0; 1]),</span>
0094 <span class="comment">%                     complement_flag (false).</span>
0095 <span class="comment">%</span>
0096 <span class="comment">% point:              This parameter describes a point. It can only be used</span>
0097 <span class="comment">%                     at the top level of an electrode geometry</span>
0098 <span class="comment">%                     description. It must be the only field in the</span>
0099 <span class="comment">%                     structure. ([])</span>
0100 <span class="comment">%</span>
0101 <span class="comment">% sphere:             A sphere is described with the following subfields:</span>
0102 <span class="comment">%                     center ([0; 0; 0]), radius (1), complement_flag</span>
0103 <span class="comment">%                     (false).</span>
0104 <span class="comment">%</span>
0105 <span class="comment">% union:              This will perform the union of all its subfields.</span>
0106 <span class="comment">%                     There is an implicit union operator at the top level</span>
0107 <span class="comment">%                     of the geometry structure. Subfields: complement_flag</span>
0108 <span class="comment">%                     (false)</span>
0109 <span class="comment">%</span>
0110 <span class="comment">% OUTPUT:</span>
0111 <span class="comment">%  fmdl               - EIDORS forward model object.</span>
0112 <span class="comment">%</span>
0113 <span class="comment">%  mat_idx            - Vector indicating for each mesh element the indices</span>
0114 <span class="comment">%                       of materials corresponding as separately defined</span>
0115 <span class="comment">%                       by input argument body_geometry.</span>
0116 <span class="comment">%</span>
0117 <span class="comment">% USAGE EXAMPLES:</span>
0118 <span class="comment">% % 3D cylinder with radius 1. One plane of 16 electrodes with radius 0.1</span>
0119 <span class="comment">%   body_geometry.cylinder = struct;</span>
0120 <span class="comment">%   n_elect = 16;</span>
0121 <span class="comment">%   theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];</span>
0122 <span class="comment">%   for i = 1:n_elect</span>
0123 <span class="comment">%     electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];</span>
0124 <span class="comment">%     electrode_geometry{i}.sphere.radius = 0.1;</span>
0125 <span class="comment">%   end</span>
0126 <span class="comment">%   fmdl = ng_mk_geometric_models(body_geometry, electrode_geometry);</span>
0127 
0128 <span class="comment">% (C) Herve Gagnon, 2015. Licenced under GPL v2 or v3</span>
0129 <span class="comment">% $Id: ng_mk_geometric_models.m 5030 2015-05-26 12:44:16Z aadler $</span>
0130 
0131 <span class="comment">% Check if function is called in UNIT_TEST mode.</span>
0132 <span class="keyword">if</span> (ischar(body_geometry) &amp;&amp; strcmp(body_geometry, <span class="string">'UNIT_TEST'</span>))
0133     <a href="#_sub24" class="code" title="subfunction do_unit_test">do_unit_test</a>; 
0134     <span class="keyword">return</span>; 
0135 <span class="keyword">end</span>
0136 
0137 <span class="comment">% Validate function parameters.</span>
0138 <span class="keyword">if</span> (isempty(body_geometry) || ~isstruct(body_geometry) &amp;&amp; ~iscell(body_geometry))
0139    error(<span class="string">'Parameter body_geometry must be a structure or a cell.'</span>);
0140 <span class="keyword">end</span>
0141 
0142 <span class="comment">% Check if parameter electrode_geometry is specified.</span>
0143 <span class="keyword">if</span> (nargin &lt; 2 || isempty(electrode_geometry))
0144     electrode_geometry = {};
0145 <span class="keyword">end</span>
0146 
0147 <span class="keyword">if</span> (~isstruct(electrode_geometry) &amp;&amp; ~iscell(electrode_geometry))
0148    error(<span class="string">'Parameter electrode_geometry must be a structure or a cell.'</span>);
0149 <span class="keyword">end</span>
0150 
0151 <span class="comment">% If parameters are not of cell type, convert them to cell.</span>
0152 <span class="keyword">if</span> (~iscell(body_geometry))
0153     body_geometry = {body_geometry};
0154 <span class="keyword">end</span>
0155 
0156 <span class="keyword">if</span> (~iscell(electrode_geometry))
0157     electrode_geometry = {electrode_geometry};
0158 <span class="keyword">end</span>
0159 
0160 <span class="comment">% Check if result is already in cache. Otherwise, compute and store in cache.</span>
0161 copt.cache_obj = {body_geometry, electrode_geometry};
0162 copt.fstr = <span class="string">'ng_mk_geometric_models'</span>;
0163 args = {body_geometry, electrode_geometry};
0164 fmdl_mat_idx = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction [fmdl_mat_idx] = mk_geometric_models(body_geometry, electrode_geometry)">mk_geometric_models</a>, args, copt);
0165 
0166 <span class="comment">% Reformat output arguments.</span>
0167 fmdl    = fmdl_mat_idx{1};
0168 mat_idx = fmdl_mat_idx{2};
0169 
0170 <a name="_sub1" href="#_subfunctions" class="code">function [fmdl_mat_idx] = mk_geometric_models(body_geometry, electrode_geometry)     </a>
0171     <span class="comment">% Find number of subdomains</span>
0172     n_body      = numel(body_geometry);
0173     n_electrode = numel(electrode_geometry);
0174 
0175     <span class="comment">% Allocate cell memory.</span>
0176     body_solid_code       = cell(size(body_geometry));
0177     body_extra_code       = cell(size(body_geometry));
0178     body_extra_param      = cell(size(body_geometry));
0179     electrode_solid_code  = cell(size(electrode_geometry));
0180     electrode_extra_code  = cell(size(electrode_geometry));
0181     electrode_extra_param = cell(size(electrode_geometry));
0182     
0183     <span class="comment">% Parse geometry for each body subdomain.</span>
0184     <span class="keyword">for</span> i = 1:n_body
0185         <span class="keyword">if</span> (isfield(body_geometry{i}, <span class="string">'point'</span>))
0186             error(<span class="string">'Field name &quot;point&quot; is not allowed for body geometry.'</span>);
0187         <span class="keyword">end</span>
0188         <span class="keyword">if</span> (isfield(body_geometry{i}, <span class="string">'enter_body_flag'</span>))
0189             error(<span class="string">'Field name &quot;enter_body_flag&quot; is not allowed for body geometry.'</span>);
0190         <span class="keyword">end</span>
0191         <span class="keyword">if</span> (isfield(body_geometry{i}, <span class="string">'keep_material_flag'</span>))
0192             error(<span class="string">'Field name &quot;keep_material_flag&quot; is not allowed for body geometry.'</span>);
0193         <span class="keyword">end</span>
0194         [body_solid_code{i} body_extra_code{i} body_extra_param{i}] = <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(body_geometry{i});  
0195     <span class="keyword">end</span>
0196     
0197     <span class="comment">% Parse geometry for each body subdomain.</span>
0198     <span class="keyword">for</span> i = 1:n_electrode
0199         [electrode_extra_code{i} electrode_extra_param{i}] = <a href="#_sub8" class="code" title="subfunction [extra_code extra_param] = parse_geometry_point(geometry)">parse_geometry_point</a>(electrode_geometry{i});
0200         <span class="keyword">if</span> (isempty(electrode_extra_param{i}.point))
0201             [electrode_solid_code{i} electrode_extra_code{i} electrode_extra_param{i}] = <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(electrode_geometry{i}); 
0202         <span class="keyword">end</span>
0203     <span class="keyword">end</span>
0204 
0205     <span class="comment">% Define temporary unique filenames.</span>
0206     fn_prefix = tempname;
0207     geo_fn    = [fn_prefix, <span class="string">'.geo'</span>];
0208     vol_fn    = [fn_prefix, <span class="string">'.vol'</span>];
0209    
0210      <span class="comment">% Add body names if unspecified.</span>
0211     <span class="keyword">for</span> i = 1:numel(body_solid_code)
0212         <span class="keyword">if</span> (isempty(body_extra_param{i}.name))
0213             body_extra_param{i}.name = sprintf(<span class="string">'body%04d'</span>, i);
0214         <span class="keyword">end</span>
0215     <span class="keyword">end</span>
0216     
0217     <span class="comment">% Add electrode names if unspecified.</span>
0218     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
0219         <span class="keyword">if</span> (isempty(electrode_extra_param{i}.name))
0220             electrode_extra_param{i}.name = sprintf(<span class="string">'electrode%04d'</span>, i);
0221         <span class="keyword">end</span>
0222     <span class="keyword">end</span>
0223 
0224     <span class="comment">% Write geo file for netgen.</span>
0225     <a href="#_sub20" class="code" title="subfunction write_geo_file(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param)">write_geo_file</a>(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param);
0226    
0227     <span class="comment">% Call netgen.</span>
0228     <a href="call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>(geo_fn, vol_fn);
0229  
0230     <span class="comment">% Read vol file generated by netgen.</span>
0231     fmdl_mat_idx{1} = <a href="#_sub22" class="code" title="subfunction fmdl = read_vol_file(vol_fn, electrode_extra_param)">read_vol_file</a>(vol_fn, electrode_extra_param);
0232     
0233     <span class="comment">% Delete temporary files.</span>
0234     <span class="keyword">if</span> ~<a href="../../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'ng_mk_geometric_models:keep_temp_files'</span>)
0235        delete(geo_fn);
0236        delete(vol_fn);
0237     <span class="keyword">end</span>
0238 
0239     <span class="comment">% Complete fmdl object.</span>
0240     fmdl_mat_idx{1} = <a href="#_sub23" class="code" title="subfunction fmdl = complete_fmdl(fmdl, electrode_extra_param)">complete_fmdl</a>(fmdl_mat_idx{1}, electrode_extra_param);
0241 
0242     <span class="comment">% Assign mat_idx value from fmdl.</span>
0243     fmdl_mat_idx{2} = fmdl_mat_idx{1}.mat_idx;
0244 
0245 <a name="_sub2" href="#_subfunctions" class="code">function radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)</a>
0246 
0247     radius = default_value;
0248     
0249     <span class="keyword">for</span> i = 1:n_structs
0250         value = struct(i).(field_name);
0251 
0252         <span class="keyword">if</span> (~isempty(value))
0253             <span class="keyword">if</span> (isscalar(value) &amp;&amp; isnumeric(value) &amp;&amp; isreal(value) &amp;&amp; value &gt; 0)
0254                 radius(i) = value;
0255             <span class="keyword">else</span> 
0256                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0257             <span class="keyword">end</span>
0258         <span class="keyword">end</span>
0259     <span class="keyword">end</span>
0260     
0261 <a name="_sub3" href="#_subfunctions" class="code">function point = assign_point(struct, n_structs, struct_name, field_name, default_value)</a>
0262         
0263     point = default_value;
0264     
0265     <span class="keyword">for</span> i = 1:n_structs
0266         value =  struct(i).(field_name);
0267 
0268         <span class="keyword">if</span> (~isempty(value))
0269             <span class="keyword">if</span> (numel(value) == 3 &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0270                 point(:, i) = value;
0271             <span class="keyword">else</span>
0272                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0273             <span class="keyword">end</span>
0274         <span class="keyword">end</span>
0275     <span class="keyword">end</span>
0276  
0277 <a name="_sub4" href="#_subfunctions" class="code">function point_list = assign_list_of_3D_points(struct, n_structs, struct_name, field_name, default_value)</a>
0278         
0279     point_list = cell(n_structs, 1);
0280     
0281     <span class="keyword">for</span> i = 1:n_structs
0282         
0283         point_list{i} = default_value;
0284         
0285         value = struct(i).(field_name);
0286 
0287         <span class="keyword">if</span> (~isempty(value))
0288             <span class="keyword">if</span> (size(value, 2) == 3 &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0289                 point_list{i} = value;
0290             <span class="keyword">else</span>
0291                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0292             <span class="keyword">end</span>
0293         <span class="keyword">end</span>
0294     <span class="keyword">end</span>
0295     
0296 <a name="_sub5" href="#_subfunctions" class="code">function segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)</a>
0297         
0298     segment_list = cell(n_structs, 1);
0299     
0300     <span class="keyword">for</span> i = 1:n_structs
0301         
0302         segment_list{i} = default_value;
0303         
0304         value = struct(i).(field_name);
0305 
0306         <span class="keyword">if</span> (~isempty(value))
0307             <span class="keyword">if</span> (size(value, 2) == 2 &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0308                 segment_list{i} = value;
0309             <span class="keyword">else</span>
0310                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0311             <span class="keyword">end</span>
0312         <span class="keyword">end</span>
0313     <span class="keyword">end</span> 
0314     
0315  <a name="_sub6" href="#_subfunctions" class="code">function segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)</a>
0316         
0317     segment_list = cell(n_structs, 1);
0318     
0319     <span class="keyword">for</span> i = 1:n_structs
0320         
0321         segment_list{i} = default_value;
0322         
0323         value = struct(i).(field_name);
0324 
0325         <span class="keyword">if</span> (~isempty(value))
0326             <span class="keyword">if</span> ((size(value, 2) == 2 || size(value, 2) == 3) &amp;&amp; isnumeric(value) &amp;&amp; isreal(value))
0327                 segment_list{i} = value;
0328             <span class="keyword">else</span>
0329                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0330             <span class="keyword">end</span>
0331         <span class="keyword">end</span>
0332     <span class="keyword">end</span>    
0333     
0334 <a name="_sub7" href="#_subfunctions" class="code">function flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)</a>
0335 
0336     flag = default_value;
0337 
0338     <span class="keyword">for</span> i = 1:n_structs
0339         value = struct(i).(field_name);
0340  
0341         <span class="keyword">if</span> (~isempty(value))
0342             <span class="keyword">if</span> (isscalar(value) &amp;&amp; (islogical(value) || (isnumeric(value) &amp;&amp; <span class="keyword">...</span>
0343                                      isreal(value) &amp;&amp; (value == 0 || value == 1))))
0344                 flag(i) = value;
0345             <span class="keyword">else</span>
0346                 error(<span class="string">'%s(%d).%s value is not valid.'</span>, struct_name, i, field_name);
0347             <span class="keyword">end</span>
0348         <span class="keyword">end</span>
0349     <span class="keyword">end</span>
0350 
0351 <a name="_sub8" href="#_subfunctions" class="code">function [extra_code extra_param] = parse_geometry_point(geometry)</a>
0352 
0353     <span class="comment">% Initialize extra param values to default values.</span>
0354     extra_code                     = <span class="string">''</span>;
0355     extra_param.point              = [];
0356     extra_param.max_edge_length    = inf;
0357     extra_param.enter_body_flag    = false;
0358     extra_param.keep_material_flag = false;
0359     extra_param.name               = <span class="string">''</span>;
0360 
0361     <span class="comment">% Check if geometry is a point, return otherwise.</span>
0362     <span class="keyword">if</span> (isfield(geometry, <span class="string">'point'</span>))
0363         <span class="comment">% Check if a single point is defined.</span>
0364         <span class="keyword">if</span> (numel(geometry) ~= 1)
0365             error(<span class="string">'Field name &quot;point&quot; must define only a single point.'</span>);
0366         <span class="keyword">end</span>
0367         
0368         <span class="comment">% Get structure field names.</span>
0369         field_names = fieldnames(geometry);
0370         n_fields = numel(field_names);
0371         
0372         <span class="comment">% Check if it is the only field names.</span>
0373         <span class="keyword">if</span> (n_fields ~= 1)
0374             <span class="keyword">if</span> (isfield(geometry, <span class="string">'name'</span>))
0375                 extra_param.name = geometry.name;
0376             <span class="keyword">else</span>
0377                 error(<span class="string">'Field name &quot;point&quot; must be used as a single field.'</span>);
0378             <span class="keyword">end</span>
0379         <span class="keyword">end</span>
0380         
0381         <span class="comment">% Check point is 3D.</span>
0382         <span class="keyword">if</span> (numel(geometry.point) ~= 3)
0383             error(<span class="string">'geometry.point value is not valid.'</span>);
0384         <span class="keyword">end</span>
0385         
0386         <span class="comment">% Set returning values.</span>
0387         extra_param.point = geometry.point(:);
0388         
0389         extra_code = sprintf(<span class="string">'point(%g, %g, %g);\n'</span>, extra_param.point);
0390     <span class="keyword">end</span>
0391     
0392 <a name="_sub9" href="#_subfunctions" class="code">function [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)</a>
0393 
0394     <span class="comment">% Extra code is initialized empty;</span>
0395     extra_code = <span class="string">''</span>;
0396     
0397     <span class="comment">% Initialize extra param values to default values.</span>
0398     extra_param.max_edge_length     = inf;
0399     extra_param.enter_body_flag     = false;
0400     extra_param.keep_material_flag  = false;
0401     extra_param.name                = <span class="string">''</span>;
0402     
0403     <span class="comment">% If called from top_level, operators default to or.</span>
0404     <span class="keyword">if</span> (nargin == 1)
0405         top_level_flag = 1;
0406         field_operator_string = <span class="string">' or '</span>;
0407         element_operator_string = <span class="string">' or '</span>;
0408     <span class="keyword">else</span>
0409         top_level_flag = 0;
0410     <span class="keyword">end</span>
0411 
0412     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with (field: &quot;%s&quot;, element: &quot;%s&quot;).'</span>, field_operator_string, element_operator_string, 4);
0413     
0414     <span class="comment">% Validate that geometry is a non-empty structure.</span>
0415     <span class="keyword">if</span> (~isstruct(geometry) || isempty(geometry))
0416         error(<span class="string">'Parameter geometry must be a valid structure.'</span>);        
0417     <span class="keyword">else</span>
0418         <span class="comment">% Get number of geometries.</span>
0419         n_geometries = numel(geometry);
0420         
0421         <span class="comment">% Get structure field names.</span>
0422         field_names = fieldnames(geometry);
0423         n_fields = numel(field_names);
0424 
0425         <span class="comment">% Recursively parse all geometry fields.</span>
0426         geo_code = <span class="string">'('</span>;
0427         <span class="keyword">for</span> i = 1:n_geometries
0428             <span class="comment">% complement_flag field has to be processed first.</span>
0429             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'complement_flag'</span>) &amp;&amp; ~isempty(geometry(i).complement_flag) &amp;&amp; geometry(i).complement_flag)
0430                  geo_code = [geo_code <span class="string">'(not('</span>];
0431             <span class="keyword">else</span>
0432                  geo_code = [geo_code <span class="string">'('</span>];
0433             <span class="keyword">end</span>
0434             <span class="comment">% Process name field.</span>
0435             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'name'</span>))
0436                 <span class="keyword">if</span> (~top_level_flag)
0437                     error(<span class="string">'Field &quot;name&quot; can only be specified at the top level of the geometry description'</span>);
0438                 <span class="keyword">end</span>
0439                 extra_param.name = geometry(i).name;
0440 
0441                 <span class="keyword">if</span> (isempty(extra_param.name) || ~ischar(extra_param.name))
0442                     error(<span class="string">'name value is not valid.'</span>);
0443                 <span class="keyword">end</span>
0444             <span class="keyword">end</span>
0445            <span class="comment">% Process max_edge_length field.</span>
0446             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'max_edge_length'</span>))
0447                 <span class="keyword">if</span> (~top_level_flag)
0448                     error(<span class="string">'Field &quot;max_edge_length&quot; can only be specified at the top level of the geometry description'</span>);
0449                 <span class="keyword">end</span>
0450                 extra_param.max_edge_length = geometry(i).max_edge_length;
0451 
0452                 <span class="keyword">if</span> (isempty(extra_param.max_edge_length) || ~isscalar(extra_param.max_edge_length) || ~isnumeric(extra_param.max_edge_length) || ~isreal(extra_param.max_edge_length) || extra_param.max_edge_length &lt;= 0)
0453                     error(<span class="string">'max_edge_length value is not valid.'</span>);
0454                 <span class="keyword">end</span>
0455             <span class="keyword">end</span>
0456             <span class="comment">% Process enter_body_flag field.</span>
0457             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'enter_body_flag'</span>))
0458                 <span class="keyword">if</span> (~top_level_flag)
0459                     error(<span class="string">'Field &quot;enter_body_flag&quot; can only be specified at the top level of the geometry description'</span>);
0460                 <span class="keyword">end</span>
0461                 extra_param.enter_body_flag = geometry(i).enter_body_flag;
0462                 
0463                 <span class="keyword">if</span> (isempty(extra_param.enter_body_flag) || ~isscalar(extra_param.enter_body_flag) || (~islogical(extra_param.enter_body_flag) &amp;&amp; <span class="keyword">...</span>
0464                         (~isnumeric(extra_param.enter_body_flag) || ~isreal(extra_param.enter_body_flag) || (extra_param.enter_body_flag ~= 0 &amp;&amp; extra_param.enter_body_flag ~= 1))))
0465                     error(<span class="string">'Field &quot;enter_body_flag value&quot; is not valid.'</span>);
0466                 <span class="keyword">end</span>
0467             <span class="keyword">end</span>
0468             <span class="comment">% Process keep_material_flag field.</span>
0469             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'keep_material_flag'</span>))
0470                 <span class="keyword">if</span> (~top_level_flag)
0471                     error(<span class="string">'Field &quot;keep_material_flag&quot; can only be specified at the top level of the geometry description'</span>);
0472                 <span class="keyword">end</span>
0473                 extra_param.keep_material_flag = geometry(i).keep_material_flag;
0474                 
0475                 <span class="keyword">if</span> (isempty(extra_param.keep_material_flag) || ~isscalar(extra_param.keep_material_flag) || (~islogical(extra_param.keep_material_flag) &amp;&amp; <span class="keyword">...</span>
0476                         (~isnumeric(extra_param.keep_material_flag) || ~isreal(extra_param.keep_material_flag) || (extra_param.keep_material_flag ~= 0 &amp;&amp; extra_param.keep_material_flag ~= 1))))
0477                     error(<span class="string">'Field &quot;keep_material_flag&quot; value is not valid.'</span>);
0478                 <span class="keyword">end</span>
0479             <span class="keyword">end</span>  
0480             first_internal_term = 1;
0481             <span class="keyword">for</span> j = 1:n_fields
0482                 <span class="keyword">if</span> (~isempty(geometry(i).(field_names{j})) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'complement_flag'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'name'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'max_edge_length'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'keep_material_flag'</span>) &amp;&amp; ~strcmp(field_names{j}, <span class="string">'enter_body_flag'</span>))
0483                     <span class="keyword">if</span> (first_internal_term)
0484                         first_internal_term = 0;
0485                     <span class="keyword">else</span>
0486                         geo_code = [geo_code field_operator_string];
0487                     <span class="keyword">end</span>
0488                     <span class="keyword">switch</span> (field_names{j})
0489                         <span class="keyword">case</span> <span class="string">'body_of_extrusion'</span>
0490                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0491                                         <a href="#_sub10" class="code" title="subfunction [geo_code extra_code] = parse_geometry_body_of_extrusion(body_of_extrusion, operator_string)">parse_geometry_body_of_extrusion</a>(geometry(i).(field_names{j}), field_operator_string);
0492                             geo_code   = [geo_code geo_code_temp];        
0493                             extra_code = [extra_code extra_code_temp];
0494                         <span class="keyword">case</span> <span class="string">'body_of_revolution'</span>
0495                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0496                                         <a href="#_sub11" class="code" title="subfunction [geo_code extra_code] = parse_geometry_body_of_revolution(body_of_revolution, operator_string)">parse_geometry_body_of_revolution</a>(geometry(i).(field_names{j}), field_operator_string);
0497                             geo_code   = [geo_code geo_code_temp];        
0498                             extra_code = [extra_code extra_code_temp];
0499                         <span class="keyword">case</span> <span class="string">'cone'</span>
0500                             geo_code = [geo_code <span class="keyword">...</span>
0501                                         <a href="#_sub12" class="code" title="subfunction geo_code = parse_geometry_cone(cone, operator_string)">parse_geometry_cone</a>(geometry(i).(field_names{j}), field_operator_string)];
0502                         <span class="keyword">case</span> <span class="string">'cylinder'</span>
0503                             geo_code = [geo_code <span class="keyword">...</span>
0504                                         <a href="#_sub13" class="code" title="subfunction geo_code = parse_geometry_cylinder(cylinder, operator_string)">parse_geometry_cylinder</a>(geometry(i).(field_names{j}), field_operator_string)];
0505                         <span class="keyword">case</span> <span class="string">'ellipsoid'</span>
0506                             geo_code = [geo_code <span class="keyword">...</span>
0507                                         <a href="#_sub14" class="code" title="subfunction geo_code = parse_geometry_ellipsoid(ellipsoid, operator_string)">parse_geometry_ellipsoid</a>(geometry(i).(field_names{j}), field_operator_string)];
0508                         <span class="keyword">case</span> <span class="string">'elliptic_cylinder'</span>
0509                             geo_code = [geo_code <span class="keyword">...</span>
0510                                         <a href="#_sub15" class="code" title="subfunction geo_code = parse_geometry_elliptic_cylinder(elliptic_cylinder, operator_string)">parse_geometry_elliptic_cylinder</a>(geometry(i).(field_names{j}), field_operator_string)];
0511                         <span class="keyword">case</span> <span class="string">'half_space'</span>
0512                             geo_code = [geo_code <span class="keyword">...</span>
0513                                         <a href="#_sub16" class="code" title="subfunction geo_code = parse_geometry_half_space(half_space, operator_string)">parse_geometry_half_space</a>(geometry(i).(field_names{j}), field_operator_string)];    
0514                         <span class="keyword">case</span> <span class="string">'ortho_brick'</span>
0515                             geo_code = [geo_code <span class="keyword">...</span>
0516                                         <a href="#_sub17" class="code" title="subfunction geo_code = parse_geometry_ortho_brick(ortho_brick, operator_string)">parse_geometry_ortho_brick</a>(geometry(i).(field_names{j}), field_operator_string)];
0517                         <span class="keyword">case</span> <span class="string">'parallelepiped'</span>
0518                             geo_code = [geo_code <span class="keyword">...</span>
0519                                         <a href="#_sub18" class="code" title="subfunction geo_code = parse_geometry_parallelepiped(parallelepiped, operator_string)">parse_geometry_parallelepiped</a>(geometry(i).(field_names{j}), field_operator_string)];       
0520                         <span class="keyword">case</span> <span class="string">'sphere'</span>
0521                             geo_code = [geo_code <span class="keyword">...</span>
0522                                         <a href="#_sub19" class="code" title="subfunction geo_code = parse_geometry_sphere(sphere, operator_string)">parse_geometry_sphere</a>(geometry(i).(field_names{j}), field_operator_string)];
0523                         <span class="keyword">case</span> <span class="string">'intersection'</span>
0524                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0525                                         <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(geometry(i).(field_names{j}), <span class="string">' and '</span>, field_operator_string);
0526                             geo_code   = [geo_code geo_code_temp];        
0527                             extra_code = [extra_code extra_code_temp];
0528                         <span class="keyword">case</span> <span class="string">'union'</span>
0529                             [geo_code_temp extra_code_temp] = <span class="keyword">...</span>
0530                                         <a href="#_sub9" class="code" title="subfunction [geo_code extra_code extra_param] = parse_geometry(geometry, field_operator_string, element_operator_string)">parse_geometry</a>(geometry(i).(field_names{j}), <span class="string">' or '</span>, field_operator_string);
0531                             geo_code   = [geo_code geo_code_temp];        
0532                             extra_code = [extra_code extra_code_temp];
0533                         <span class="keyword">otherwise</span>
0534                             error([<span class="string">'Field name &quot;%s&quot; is not valid for a geometry.\nAvailable field names for a geometry are: '</span><span class="keyword">...</span>
0535                                    <span class="string">'complement_flag, intersection, union, body_of_extrusion, body_of_revolution, cone, cylinder, ellipsoid, elliptic_cylinder, half_space, ortho_brick, parallelepiped, point, sphere, keep_material_flag, enter_body_flag, name, and max_edge_length.'</span>], field_names{j});
0536                     <span class="keyword">end</span>
0537                 <span class="keyword">end</span>
0538             <span class="keyword">end</span>
0539             <span class="keyword">if</span> (isfield(geometry(i), <span class="string">'complement_flag'</span>) &amp;&amp; ~isempty(geometry(i).complement_flag) &amp;&amp; geometry(i).complement_flag)
0540                 geo_code = [geo_code <span class="string">'))'</span>];
0541             <span class="keyword">else</span>
0542                 geo_code = [geo_code <span class="string">')'</span>];  
0543             <span class="keyword">end</span>
0544            
0545             <span class="keyword">if</span> (i &lt; n_geometries)
0546                 geo_code = [geo_code element_operator_string];         
0547             <span class="keyword">end</span>           
0548         <span class="keyword">end</span>
0549         geo_code = [geo_code <span class="string">')'</span>];  
0550     <span class="keyword">end</span>
0551     
0552     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ returned with (field: &quot;%s&quot;, element: &quot;%s&quot;).'</span>, field_operator_string, element_operator_string, 4);
0553  
0554 <a name="_sub10" href="#_subfunctions" class="code">function [geo_code extra_code] = parse_geometry_body_of_extrusion(body_of_extrusion, operator_string)</a>
0555 
0556     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
0557 
0558     <span class="keyword">if</span> (~isstruct(body_of_extrusion) || isempty(body_of_extrusion))
0559         error(<span class="string">'Parameter body_of_extrusion must be a valid structure.'</span>);        
0560     <span class="keyword">else</span>
0561         <span class="comment">% Get number of body_of_extrusion.</span>
0562         n_body_of_extrusions = numel(body_of_extrusion);
0563         
0564         <span class="comment">% Get structure field names.</span>
0565         field_names = fieldnames(body_of_extrusion);
0566         n_fields = numel(field_names);
0567         
0568         <span class="comment">% Assign default values.</span>
0569         vector_d            = [0; 1; 0]*ones(1, n_body_of_extrusions);
0570         profile_points{1}   = [1 1; 1 2; 2 2; 2 1];
0571         profile_segments{1} = [1 2; 2 3; 3 4; 4 1];
0572         path_points{1}      = [0 0 0; 0 0 1; 0 0 2; 0 0 3];
0573         path_segments{1}    = [1 2; 2 3; 3 4];
0574         complement_flag     = false(1, n_body_of_extrusions);
0575         
0576         <span class="comment">% Parse all structure fields.</span>
0577         <span class="keyword">for</span> i = 1:n_fields
0578             <span class="keyword">switch</span> (field_names{i})
0579                 <span class="keyword">case</span> <span class="string">'vector_d'</span>
0580                     vector_d = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, vector_d);
0581                 <span class="keyword">case</span> <span class="string">'profile_points'</span>
0582                     profile_points = <a href="#_sub5" class="code" title="subfunction segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, profile_points{1});
0583                 <span class="keyword">case</span> <span class="string">'profile_segments'</span>
0584                     profile_segments = <a href="#_sub6" class="code" title="subfunction segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_or_3D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, profile_segments{1});
0585                 <span class="keyword">case</span> <span class="string">'path_points'</span>
0586                     path_points = <a href="#_sub4" class="code" title="subfunction point_list = assign_list_of_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_3D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, path_points{1});
0587                 <span class="keyword">case</span> <span class="string">'path_segments'</span>
0588                     path_segments = <a href="#_sub6" class="code" title="subfunction segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_or_3D_points</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, path_segments{1});
0589                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0590                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(body_of_extrusion, n_body_of_extrusions, <span class="string">'body_of_extrusion'</span>, field_names{i}, complement_flag);
0591                 <span class="keyword">otherwise</span>
0592                     error([<span class="string">'Field name &quot;%s&quot; is not allowed for a body_of_extrusion!\nAllowed field names for a body_of_extrusion are: '</span> <span class="keyword">...</span>
0593                            <span class="string">'path_points, path_segments, profile_points, profile_segments, vector_d, and complement_flag.'</span>], field_names{i});
0594             <span class="keyword">end</span>
0595         <span class="keyword">end</span>
0596         
0597         <span class="comment">% Start geo code with an opening parenthesis.</span>
0598         geo_code = <span class="string">'('</span>;
0599         extra_code = <span class="string">''</span>;
0600         
0601         <span class="comment">% Add geo code for each body_of_extrusion.</span>
0602         <span class="keyword">for</span> i = 1:n_body_of_extrusions
0603             
0604             <span class="keyword">for</span> j = 1:size(path_segments{i}, 1)
0605                 <span class="keyword">if</span> (dot(vector_d(:,i), path_points{i}(path_segments{i}(j, 1), :) - path_points{i}(path_segments{i}(j, end), :)) ~= 0)
0606                     error(<span class="string">'vector_d and path must be perpendicular for a body of extrusion.'</span>);
0607                 <span class="keyword">end</span>
0608             <span class="keyword">end</span>
0609             
0610             n_points = size(profile_points{i}, 1);
0611             n_segments = size(profile_segments{i}, 1);
0612             
0613             <span class="keyword">if</span> (size(profile_segments{i}, 2) == 2)
0614                 extra_code = [extra_code sprintf(<span class="string">'curve2d Extrusion2DProfileCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0615                                          sprintf(<span class="string">'%g, %g ; '</span>, profile_points{i}') <span class="keyword">...</span>
0616                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0617                                          sprintf(<span class="string">'; 2, %g, %g '</span>, profile_segments{i}') <span class="keyword">...</span>
0618                                          sprintf(<span class="string">');\n\n'</span>)];
0619             <span class="keyword">else</span>
0620                 extra_code = [extra_code sprintf(<span class="string">'curve2d Extrusion2DProfileCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0621                                          sprintf(<span class="string">'%g, %g ; '</span>, profile_points{i}') <span class="keyword">...</span>
0622                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0623                                          sprintf(<span class="string">'; 3, %g, %g, %g '</span>, profile_segments{i}') <span class="keyword">...</span>
0624                                          sprintf(<span class="string">');\n\n'</span>)];
0625             <span class="keyword">end</span>
0626   
0627             n_points = size(path_points{i}, 1);
0628             n_segments = size(path_segments{i}, 1);
0629             
0630             <span class="keyword">if</span> (size(path_segments{i}, 2) == 2)
0631                 extra_code = [extra_code sprintf(<span class="string">'curve3d Extrusion3DPathCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0632                                          sprintf(<span class="string">'%g, %g, %g ; '</span>, path_points{i}') <span class="keyword">...</span>
0633                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0634                                          sprintf(<span class="string">'; 2, %g, %g '</span>, path_segments{i}') <span class="keyword">...</span>
0635                                          sprintf(<span class="string">');\n\n'</span>)];
0636             <span class="keyword">else</span>
0637                  extra_code = [extra_code sprintf(<span class="string">'curve3d Extrusion3DPathCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0638                                          sprintf(<span class="string">'%g, %g, %g ; '</span>, path_points{i}') <span class="keyword">...</span>
0639                                          sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0640                                          sprintf(<span class="string">'; 3, %g, %g, %g '</span>, path_segments{i}') <span class="keyword">...</span>
0641                                          sprintf(<span class="string">');\n\n'</span>)];               
0642             <span class="keyword">end</span>
0643                                        
0644             <span class="keyword">if</span> (complement_flag(i))
0645                 geo_code = [geo_code <span class="string">'not '</span>];
0646             <span class="keyword">end</span>
0647             
0648             <span class="comment">% Check if path is closed.</span>
0649             <span class="keyword">if</span> (path_segments{i}(end) == path_segments{i}(1))
0650                 geo_code = [geo_code sprintf(<span class="string">'extrusion(Extrusion3DPathCurve%d ; Extrusion2DProfileCurve%d ; %g, %g, %g)'</span>, i, i, vector_d(:,i))];
0651             <span class="keyword">else</span>
0652                 <span class="comment">%error('Unclosed path are not yet supported for body of extrusion!');</span>
0653                 <span class="comment">%for j = 1: [1 1; 1 2; 2 2; 2 1];</span>
0654                 <span class="comment">%polyhedron1 = 'polyhedron(-1, 1, 0; -1, 2, 0; -2, 2, 0; -2, 1, 0; -1.5, 1.5, 0; -1.5, 1.5, 1 ;; 2, 1, 5; 3, 2, 5; 4, 3, 5; 1, 4, 5; 1, 2, 6; 2, 3, 6; 3, 4, 6; 4, 1, 6)';</span>
0655                 <span class="comment">%polyhedron2 = 'polyhedron(-1, 1, 3; -1, 2, 3; -2, 2, 3; -2, 1, 3; -1.5, 1.5, 3; -1.5, 1.5, 2 ;; 1, 2, 5; 2, 3, 5; 3, 4, 5; 4, 1, 5; 2, 1, 6; 3, 2, 6; 4, 3, 6; 1, 4, 6)';</span>
0656                 <span class="comment">%polyhedron1 = 'plane(0, 0, 3; 0, 0, 1)';</span>
0657                 <span class="comment">%polyhedron2 = 'plane(0, 0, 0; 0, 0, -1)';</span>
0658                 first_point  = path_points{i}(path_segments{i}(1, 1), :);
0659                 first_vector = first_point - path_points{i}(path_segments{i}(1, end), :);
0660                 last_point   = path_points{i}(path_segments{i}(<span class="keyword">end</span>, end), :);
0661                 last_vector  = last_point - path_points{i}(path_segments{i}(<span class="keyword">end</span>, 1), :);
0662                 geo_code = [geo_code sprintf(<span class="string">'(extrusion(Extrusion3DPathCurve%d ; Extrusion2DProfileCurve%d ; %g, %g, %g) and plane(%g, %g, %g; %g, %g, %g) and plane(%g, %g, %g; %g, %g, %g))'</span>, <span class="keyword">...</span>
0663                             i, i, vector_d(:,i), first_point, first_vector, last_point, last_vector)];
0664                 <span class="comment">%geo_code = [geo_code sprintf('(%s or %s)', polyhedron1, polyhedron2)];</span>
0665             <span class="keyword">end</span>
0666 
0667             <span class="keyword">if</span> (i &lt; n_body_of_extrusions)
0668                 geo_code = [geo_code operator_string];
0669             <span class="keyword">else</span>
0670                 geo_code = [geo_code <span class="string">')'</span>];             
0671             <span class="keyword">end</span>
0672         <span class="keyword">end</span>
0673     <span class="keyword">end</span>
0674     
0675     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
0676 
0677 <a name="_sub11" href="#_subfunctions" class="code">function [geo_code extra_code] = parse_geometry_body_of_revolution(body_of_revolution, operator_string)</a>
0678 
0679     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
0680 
0681     <span class="keyword">if</span> (~isstruct(body_of_revolution) || isempty(body_of_revolution))
0682         error(<span class="string">'Parameter body_of_revolution must be a valid structure.'</span>);        
0683     <span class="keyword">else</span>
0684         <span class="comment">% Get number of body_of_revolution.</span>
0685         n_body_of_revolutions = numel(body_of_revolution);
0686         
0687         <span class="comment">% Get structure field names.</span>
0688         field_names = fieldnames(body_of_revolution);
0689         n_fields = numel(field_names);
0690         
0691         <span class="comment">% Assign default values.</span>
0692         axis_point_a   = [0;0;0]*ones(1, n_body_of_revolutions);
0693         axis_point_b   = [0;0;1]*ones(1, n_body_of_revolutions);
0694         points{1}      = [1 1; 1 2; 2 2; 2 1];
0695         segments{1}    = [1 2; 2 3; 3 4; 4 1];
0696         complement_flag = false(1, n_body_of_revolutions);
0697         
0698         <span class="comment">% Parse all structure fields.</span>
0699         <span class="keyword">for</span> i = 1:n_fields
0700             <span class="keyword">switch</span> (field_names{i})
0701                 <span class="keyword">case</span> <span class="string">'axis_point_a'</span>
0702                     axis_point_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, axis_point_a);
0703                 <span class="keyword">case</span> <span class="string">'axis_point_b'</span>
0704                     axis_point_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, axis_point_b);
0705                 <span class="keyword">case</span> <span class="string">'points'</span>
0706                     points = <a href="#_sub5" class="code" title="subfunction segment_list = assign_list_of_2D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_points</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, points{1});
0707                 <span class="keyword">case</span> <span class="string">'segments'</span>
0708                     segments = <a href="#_sub6" class="code" title="subfunction segment_list = assign_list_of_2D_or_3D_points(struct, n_structs, struct_name, field_name, default_value)">assign_list_of_2D_or_3D_points</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, segments{1});
0709                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0710                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(body_of_revolution, n_body_of_revolutions, <span class="string">'body_of_revolution'</span>, field_names{i}, complement_flag);
0711                 <span class="keyword">otherwise</span>
0712                     error([<span class="string">'Field name ''%s'' is not valid for a body_of_revolution.\Available field names for a body_of_revolution are: '</span> <span class="keyword">...</span>
0713                            <span class="string">'axis_point_a, axis_point_b, points, segments, and complement_flag.'</span>], field_names{i});
0714             <span class="keyword">end</span>
0715         <span class="keyword">end</span>
0716         
0717         <span class="comment">% Start geo code with an opening parenthesis.</span>
0718         geo_code = <span class="string">'('</span>;
0719         extra_code = <span class="string">''</span>;
0720         
0721         <span class="comment">% Add geo code for each body_of_revolution.</span>
0722         <span class="keyword">for</span> i = 1:n_body_of_revolutions
0723             
0724             n_points = size(points{i}, 1);
0725             n_segments = size(segments{i}, 1);
0726             
0727             <span class="keyword">if</span> (size(segments{i}, 2) == 2)
0728                 extra_code = [extra_code sprintf(<span class="string">'curve2d Revolution2DCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0729                                                sprintf(<span class="string">'%g, %g ; '</span>, points{i}') <span class="keyword">...</span>
0730                                                sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0731                                                sprintf(<span class="string">'; 2, %g, %g '</span>, segments{i}') <span class="keyword">...</span>
0732                                                sprintf(<span class="string">');\n\n'</span>)];
0733             <span class="keyword">else</span>
0734                 extra_code = [extra_code sprintf(<span class="string">'curve2d Revolution2DCurve%d = (%g ; '</span>, i, n_points) <span class="keyword">...</span>
0735                                                sprintf(<span class="string">'%g, %g ; '</span>, points{i}') <span class="keyword">...</span>
0736                                                sprintf(<span class="string">' %g '</span>, n_segments) <span class="keyword">...</span>
0737                                                sprintf(<span class="string">'; 3, %g, %g, %g '</span>, segments{i}') <span class="keyword">...</span>
0738                                                sprintf(<span class="string">');\n\n'</span>)];
0739             <span class="keyword">end</span>
0740             
0741             <span class="keyword">if</span> (complement_flag(i))
0742                 geo_code = [geo_code <span class="string">'not '</span>];
0743             <span class="keyword">end</span>
0744             
0745             geo_code = [geo_code sprintf(<span class="string">'revolution(%g, %g, %g ; %g, %g, %g ; Revolution2DCurve%d)'</span>, <span class="keyword">...</span>
0746                         axis_point_a(:, i), axis_point_b(:, i), i)];
0747 
0748             <span class="keyword">if</span> (i &lt; n_body_of_revolutions)
0749                 geo_code = [geo_code operator_string];
0750             <span class="keyword">else</span>
0751                 geo_code = [geo_code <span class="string">')'</span>];             
0752             <span class="keyword">end</span>
0753         <span class="keyword">end</span>
0754     <span class="keyword">end</span>
0755     
0756     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
0757     
0758 <a name="_sub12" href="#_subfunctions" class="code">function geo_code = parse_geometry_cone(cone, operator_string)</a>
0759 
0760     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
0761 
0762     <span class="keyword">if</span> (~isstruct(cone) || isempty(cone))
0763         error(<span class="string">'Parameter cone must be a valid structure.'</span>);        
0764     <span class="keyword">else</span>
0765         <span class="comment">% Get number of cones.</span>
0766         n_cones = numel(cone);
0767         
0768         <span class="comment">% Get structure field names.</span>
0769         field_names = fieldnames(cone);
0770         n_fields = numel(field_names);
0771         
0772         <span class="comment">% Assign default values.</span>
0773         top_radius      = 0.5*ones(1, n_cones);
0774         bottom_radius   = ones(1, n_cones);
0775         top_center      = [0;0;1]*ones(1, n_cones);
0776         bottom_center   = [0;0;0]*ones(1, n_cones);
0777         complement_flag = false(1, n_cones);
0778         
0779         <span class="comment">% Parse all structure fields.</span>
0780         <span class="keyword">for</span> i = 1:n_fields
0781             <span class="keyword">switch</span> (field_names{i})
0782                 <span class="keyword">case</span> <span class="string">'top_radius'</span>
0783                     top_radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, top_radius);
0784                 <span class="keyword">case</span> <span class="string">'bottom_radius'</span>
0785                     bottom_radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, bottom_radius);
0786                 <span class="keyword">case</span> {<span class="string">'top_center'</span>, <span class="string">'top_centre'</span>}
0787                     top_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, top_center);
0788                 <span class="keyword">case</span> {<span class="string">'bottom_center'</span>, <span class="string">'bottom_centre'</span>}
0789                     bottom_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, bottom_center);
0790                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0791                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(cone, n_cones, <span class="string">'cone'</span>, field_names{i}, complement_flag);
0792                 <span class="keyword">otherwise</span>
0793                     error([<span class="string">'Field name ''%s'' is not valid for a cone.\Available field names for a cone are: '</span> <span class="keyword">...</span>
0794                            <span class="string">'bottom_center, bottom_radius, top_center, top_radius, and complement_flag.'</span>], field_names{i});
0795             <span class="keyword">end</span>
0796         <span class="keyword">end</span>
0797         
0798         <span class="comment">% Start geo code with an opening parenthesis.</span>
0799         geo_code = <span class="string">'('</span>;
0800 
0801         <span class="comment">% Add geo code for each cone.</span>
0802         <span class="keyword">for</span> i = 1:n_cones
0803             <span class="keyword">if</span> (complement_flag(i))
0804                 geo_code = [geo_code <span class="string">'not '</span>];
0805             <span class="keyword">end</span>
0806             
0807             n_vector = top_center(:,i) - bottom_center(:,i); 
0808             
0809             geo_code = [geo_code sprintf(<span class="string">'(cone(%g, %g, %g ; %g ; %g, %g, %g ; %g) and plane(%g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g))'</span>, <span class="keyword">...</span>
0810                         bottom_center(:,i), bottom_radius(i), top_center(:,i), top_radius(i), bottom_center(:,i), -n_vector, top_center(:,i), n_vector)];
0811 
0812             <span class="keyword">if</span> (i &lt; n_cones)
0813                 geo_code = [geo_code operator_string];
0814             <span class="keyword">else</span>
0815                 geo_code = [geo_code <span class="string">')'</span>];             
0816             <span class="keyword">end</span>
0817         <span class="keyword">end</span>
0818     <span class="keyword">end</span>
0819     
0820     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
0821     
0822 <a name="_sub13" href="#_subfunctions" class="code">function geo_code = parse_geometry_cylinder(cylinder, operator_string)</a>
0823 
0824     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
0825 
0826     <span class="keyword">if</span> (~isstruct(cylinder) || isempty(cylinder))
0827         error(<span class="string">'Parameter cylinder must be a valid structure.'</span>);        
0828     <span class="keyword">else</span>
0829         <span class="comment">% Get number of cylinders.</span>
0830         n_cylinders = numel(cylinder);
0831         
0832         <span class="comment">% Get structure field names.</span>
0833         field_names = fieldnames(cylinder);
0834         n_fields = numel(field_names);
0835         
0836         <span class="comment">% Assign default values.</span>
0837         radius          = ones(1, n_cylinders);
0838         top_center      = [0;0;1]*ones(1, n_cylinders);
0839         bottom_center   = [0;0;0]*ones(1, n_cylinders);
0840         complement_flag = false(1, n_cylinders);
0841         
0842         <span class="comment">% Parse all structure fields.</span>
0843         <span class="keyword">for</span> i = 1:n_fields
0844             <span class="keyword">switch</span> (field_names{i})
0845                 <span class="keyword">case</span> <span class="string">'radius'</span>
0846                     radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, radius);     
0847                 <span class="keyword">case</span> {<span class="string">'top_center'</span>, <span class="string">'top_centre'</span>}
0848                     top_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, top_center);
0849                 <span class="keyword">case</span> {<span class="string">'bottom_center'</span>, <span class="string">'bottom_centre'</span>}
0850                     bottom_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, bottom_center);
0851                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0852                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(cylinder, n_cylinders, <span class="string">'cylinder'</span>, field_names{i}, complement_flag);
0853                 <span class="keyword">otherwise</span>
0854                     error([<span class="string">'Field name ''%s'' is not valid for a cylinder!\nAvailable field names for a cylinder are: '</span><span class="keyword">...</span>
0855                            <span class="string">'bottom_center, top_center, radius, and complement_flag.'</span>], field_names{i});
0856             <span class="keyword">end</span>
0857         <span class="keyword">end</span>
0858         
0859         <span class="comment">% Start geo code with an opening parenthesis.</span>
0860         geo_code = <span class="string">'('</span>;
0861 
0862         <span class="comment">% Add geo code for each cylinder.</span>
0863         <span class="keyword">for</span> i = 1:n_cylinders
0864             <span class="keyword">if</span> (complement_flag(i))
0865                 geo_code = [geo_code <span class="string">'not '</span>];
0866             <span class="keyword">end</span>
0867             
0868             n_vector = top_center(:,i) - bottom_center(:,i); 
0869             
0870             geo_code = [geo_code sprintf(<span class="string">'(cylinder(%g, %g, %g ; %g, %g, %g ; %g) and plane(%g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g))'</span>, <span class="keyword">...</span>
0871                         bottom_center(:,i), top_center(:,i), radius(i), bottom_center(:,i), -n_vector, top_center(:,i), n_vector)];
0872                     
0873             <span class="keyword">if</span> (i &lt; n_cylinders)
0874                 geo_code = [geo_code operator_string];
0875             <span class="keyword">else</span>
0876                 geo_code = [geo_code <span class="string">')'</span>];             
0877             <span class="keyword">end</span>
0878         <span class="keyword">end</span>
0879     <span class="keyword">end</span>
0880     
0881     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
0882     
0883 <a name="_sub14" href="#_subfunctions" class="code">function geo_code = parse_geometry_ellipsoid(ellipsoid, operator_string)</a>
0884 
0885     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
0886 
0887     <span class="keyword">if</span> (~isstruct(ellipsoid) || isempty(ellipsoid))
0888         error(<span class="string">'Parameter ellipsoid must be a valid structure.'</span>);        
0889     <span class="keyword">else</span>
0890         <span class="comment">% Get number of ellipsoids.</span>
0891         n_ellipsoids = numel(ellipsoid);
0892         
0893         <span class="comment">% Get structure field names.</span>
0894         field_names = fieldnames(ellipsoid);
0895         n_fields = numel(field_names);
0896   
0897         <span class="comment">% Assign default values.</span>
0898         axis_a          = [1;0;0]*ones(1, n_ellipsoids);
0899         axis_b          = [0;1;0]*ones(1, n_ellipsoids);
0900         axis_c          = [0;0;1]*ones(1, n_ellipsoids);
0901         center          = [0;0;0]*ones(1, n_ellipsoids);
0902         complement_flag = false(1, n_ellipsoids);
0903         
0904         <span class="comment">% Parse all structure fields.</span>
0905         <span class="keyword">for</span> i = 1:n_fields
0906             <span class="keyword">switch</span> (field_names{i})   
0907                 <span class="keyword">case</span> {<span class="string">'center'</span>, <span class="string">'centre'</span>}
0908                     center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, center);
0909                 <span class="keyword">case</span> <span class="string">'axis_a'</span>
0910                     axis_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, axis_a);
0911                 <span class="keyword">case</span> <span class="string">'axis_b'</span>
0912                     axis_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, axis_b);
0913                 <span class="keyword">case</span> <span class="string">'axis_c'</span>
0914                     axis_c = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, axis_c);
0915                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0916                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(ellipsoid, n_ellipsoids, <span class="string">'ellipsoid'</span>, field_names{i}, complement_flag);
0917                 <span class="keyword">otherwise</span>
0918                      error([<span class="string">'Field name ''%s'' is not valid for an ellipsoid!\nAvailable field names for an ellipsoid are: '</span><span class="keyword">...</span>
0919                            <span class="string">'center, axis_a, axis_b, axis_c, and complement_flag.'</span>], field_names{i});
0920             <span class="keyword">end</span>
0921         <span class="keyword">end</span>
0922         
0923         <span class="comment">% Start geo code with an opening parenthesis.</span>
0924         geo_code = <span class="string">'('</span>;
0925 
0926         <span class="comment">% Add geo code for each ellipsoid.</span>
0927         <span class="keyword">for</span> i = 1:n_ellipsoids
0928             <span class="keyword">if</span> (dot(axis_a(:,i), axis_b(:,i)) ~= 0)
0929                 error(<span class="string">'axis_a and axis_b have to be perpendicular for an ellipsoid.'</span>);
0930             <span class="keyword">elseif</span> (dot(axis_a(:,i), axis_c(:,i)) ~= 0)
0931                 error(<span class="string">'axis_a and axis_c have to be perpendicular for an ellipsoid.'</span>);
0932             <span class="keyword">elseif</span> (dot(axis_b(:,i), axis_c(:,i)) ~= 0)
0933                 error(<span class="string">'axis_b and axis_c have to be perpendicular for an ellipsoid.'</span>);
0934             <span class="keyword">end</span>
0935             
0936             <span class="keyword">if</span> (complement_flag(i))
0937                 geo_code = [geo_code <span class="string">'not '</span>];
0938             <span class="keyword">end</span>
0939                 
0940             geo_code = [geo_code sprintf(<span class="string">'ellipsoid(%g, %g, %g ; %g, %g, %g ; %g, %g, %g ; %g, %g, %g)'</span>, <span class="keyword">...</span>
0941                         center(:,i), axis_a(:, i), axis_b(:,i) , axis_c(:,i))];
0942                     
0943             <span class="keyword">if</span> (i &lt; n_ellipsoids)
0944                 geo_code = [geo_code operator_string];
0945             <span class="keyword">else</span>
0946                 geo_code = [geo_code <span class="string">')'</span>];             
0947             <span class="keyword">end</span>
0948         <span class="keyword">end</span>
0949     <span class="keyword">end</span>
0950     
0951     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
0952       
0953 <a name="_sub15" href="#_subfunctions" class="code">function geo_code = parse_geometry_elliptic_cylinder(elliptic_cylinder, operator_string)</a>
0954 
0955     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
0956 
0957     <span class="keyword">if</span> (~isstruct(elliptic_cylinder) || isempty(elliptic_cylinder))
0958         error(<span class="string">'Parameter elliptic_cylinder must be a valid structure.'</span>);        
0959     <span class="keyword">else</span>
0960         <span class="comment">% Get number of elliptic_cylinders.</span>
0961         n_elliptic_cylinders = numel(elliptic_cylinder);
0962         
0963         <span class="comment">% Get structure field names.</span>
0964         field_names = fieldnames(elliptic_cylinder);
0965         n_fields = numel(field_names);
0966         
0967         <span class="comment">% Assign default values.</span>
0968         top_center      = [0;0;1]*ones(1, n_elliptic_cylinders);
0969         bottom_center   = [0;0;0]*ones(1, n_elliptic_cylinders);
0970         axis_a          = [1;0;0]*ones(1, n_elliptic_cylinders);
0971         axis_b          = [0;1;0]*ones(1, n_elliptic_cylinders);
0972         complement_flag = false(1, n_elliptic_cylinders);
0973         
0974         <span class="comment">% Parse all structure fields.</span>
0975         <span class="keyword">for</span> i = 1:n_fields
0976             <span class="keyword">switch</span> (field_names{i})   
0977                 <span class="keyword">case</span> {<span class="string">'top_center'</span>, <span class="string">'top_centre'</span>}
0978                     top_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, top_center);
0979                 <span class="keyword">case</span> {<span class="string">'bottom_center'</span>, <span class="string">'bottom_centre'</span>}
0980                     bottom_center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, bottom_center);
0981                 <span class="keyword">case</span> <span class="string">'axis_a'</span>
0982                     axis_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, axis_a);
0983                 <span class="keyword">case</span> <span class="string">'axis_b'</span>
0984                     axis_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, axis_b);
0985                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
0986                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(elliptic_cylinder, n_elliptic_cylinders, <span class="string">'elliptic_cylinder'</span>, field_names{i}, complement_flag);
0987                 <span class="keyword">otherwise</span>
0988                     error([<span class="string">'Field name ''%s'' is not valid for an elliptic cylinder!\nAvailable field names for an elliptic cylinder are: '</span><span class="keyword">...</span>
0989                            <span class="string">'bottom_center, top_center, axis_a, axis_b, and complement_flag.'</span>], field_names{i});
0990             <span class="keyword">end</span>
0991         <span class="keyword">end</span>
0992         
0993         <span class="comment">% Start geo code with an opening parenthesis.</span>
0994         geo_code = <span class="string">'('</span>;
0995 
0996         <span class="comment">% Add geo code for each cylinder.</span>
0997         <span class="keyword">for</span> i = 1:n_elliptic_cylinders
0998             <span class="keyword">if</span> (complement_flag(i))
0999                 geo_code = [geo_code <span class="string">'not '</span>];
1000             <span class="keyword">end</span>
1001             
1002             central_axis = top_center(:,i) - bottom_center(:,i);
1003             
1004             <span class="keyword">if</span> (dot(axis_a(:,i), axis_b(:,i)) ~= 0)
1005                 error(<span class="string">'axis_a and axis_b have to be perpendicular for an elliptic cylinder.'</span>);
1006             <span class="keyword">elseif</span> (dot(axis_a(:,i), central_axis(:,i)) ~= 0)
1007                 error(<span class="string">'axis_a and the central axis have to be perpendicular for an elliptic cylinder.'</span>);
1008             <span class="keyword">elseif</span> (dot(axis_b(:,i), central_axis(:,i)) ~= 0)
1009                 error(<span class="string">'axis_b and the central axis have to be perpendicular for an elliptic cylinder.'</span>);
1010             <span class="keyword">end</span>
1011             
1012             geo_code = [geo_code sprintf(<span class="string">'(ellipticcylinder(%g, %g, %g ; %g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g) and plane(%g, %g, %g ; %g, %g, %g))'</span>, <span class="keyword">...</span>
1013                         bottom_center(:,i), axis_a(:,i), axis_b(:,i), bottom_center(:,i), -central_axis, top_center(:,i), central_axis)];
1014                     
1015             <span class="keyword">if</span> (i &lt; n_elliptic_cylinders)
1016                 geo_code = [geo_code operator_string];
1017             <span class="keyword">else</span>
1018                 geo_code = [geo_code <span class="string">')'</span>];             
1019             <span class="keyword">end</span>
1020         <span class="keyword">end</span>
1021     <span class="keyword">end</span>
1022     
1023     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
1024     
1025 <a name="_sub16" href="#_subfunctions" class="code">function geo_code = parse_geometry_half_space(half_space, operator_string)</a>
1026 
1027     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
1028 
1029     <span class="keyword">if</span> (~isstruct(half_space) || isempty(half_space))
1030         error(<span class="string">'Parameter half_space must be a valid structure.'</span>);        
1031     <span class="keyword">else</span>
1032         <span class="comment">% Get number of half_spaces.</span>
1033         n_half_spaces = numel(half_space);
1034         
1035         <span class="comment">% Get structure field names.</span>
1036         field_names = fieldnames(half_space);
1037         n_fields = numel(field_names);
1038         
1039         <span class="comment">% Assign default values.</span>
1040         point           = [0;0;0]*ones(1, n_half_spaces);
1041         outward_normal_vector  = [0;0;1]*ones(1, n_half_spaces);
1042         complement_flag = false(1, n_half_spaces);
1043         
1044         <span class="comment">% Parse all structure fields.</span>
1045         <span class="keyword">for</span> i = 1:n_fields
1046             <span class="keyword">switch</span> (field_names{i})  
1047                 <span class="keyword">case</span> <span class="string">'point'</span>
1048                     point = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(half_space, n_half_spaces, <span class="string">'half_space'</span>, field_names{i}, point);
1049                 <span class="keyword">case</span> <span class="string">'outward_normal_vector'</span>
1050                     outward_normal_vector = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(half_space, n_half_spaces, <span class="string">'half_space'</span>, field_names{i}, outward_normal_vector);
1051                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1052                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(half_space, n_half_spaces, <span class="string">'half_space'</span>, field_names{i}, complement_flag);
1053                 <span class="keyword">otherwise</span>
1054                     error([<span class="string">'Field name ''%s'' is not valid for a half_space!\Available field names for a half_space are: '</span> <span class="keyword">...</span>
1055                            <span class="string">'point, outward_normal_vector, and complement_flag.'</span>], field_names{i});
1056             <span class="keyword">end</span>
1057         <span class="keyword">end</span>
1058         
1059         <span class="comment">% Start geo code with an opening parenthesis.</span>
1060         geo_code = <span class="string">'('</span>;
1061 
1062         <span class="comment">% Add geo code for each half_space.</span>
1063         <span class="keyword">for</span> i = 1:n_half_spaces
1064             <span class="keyword">if</span> (complement_flag(i))
1065                 geo_code = [geo_code <span class="string">'not '</span>];
1066             <span class="keyword">end</span>
1067             
1068             geo_code = [geo_code sprintf(<span class="string">'plane(%g, %g, %g ; %g, %g, %g)'</span>, <span class="keyword">...</span>
1069                         point(:,i), outward_normal_vector(:,i))];
1070                     
1071             <span class="keyword">if</span> (i &lt; n_half_spaces)
1072                 geo_code = [geo_code operator_string];
1073             <span class="keyword">else</span>
1074                 geo_code = [geo_code <span class="string">')'</span>];             
1075             <span class="keyword">end</span>
1076         <span class="keyword">end</span>
1077     <span class="keyword">end</span>
1078     
1079     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
1080 
1081 <a name="_sub17" href="#_subfunctions" class="code">function geo_code = parse_geometry_ortho_brick(ortho_brick, operator_string)</a>
1082 
1083     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
1084 
1085     <span class="keyword">if</span> (~isstruct(ortho_brick) || isempty(ortho_brick))
1086         error(<span class="string">'Parameter ortho_brick must be a valid structure.'</span>);        
1087     <span class="keyword">else</span>
1088         <span class="comment">% Get number of ortho_bricks.</span>
1089         n_ortho_bricks = numel(ortho_brick);
1090         
1091         <span class="comment">% Get structure field names.</span>
1092         field_names = fieldnames(ortho_brick);
1093         n_fields = numel(field_names);
1094         
1095         <span class="comment">% Assign default values.</span>
1096         opposite_corner_a = [0;0;0]*ones(1, n_ortho_bricks);
1097         opposite_corner_b = [1;1;1]*ones(1, n_ortho_bricks);
1098         complement_flag   = zeros(1, n_ortho_bricks);
1099         
1100         <span class="comment">% Parse all structure fields.</span>
1101         <span class="keyword">for</span> i = 1:n_fields
1102             <span class="keyword">switch</span> (field_names{i})  
1103                 <span class="keyword">case</span> {<span class="string">'opposite_corner_a'</span>}
1104                     opposite_corner_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ortho_brick, n_ortho_bricks, <span class="string">'ortho_brick'</span>, field_names{i}, opposite_corner_a);
1105                 <span class="keyword">case</span> {<span class="string">'opposite_corner_b'</span>}
1106                     opposite_corner_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(ortho_brick, n_ortho_bricks, <span class="string">'ortho_brick'</span>, field_names{i}, opposite_corner_b);
1107                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1108                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(ortho_brick, n_ortho_bricks, <span class="string">'ortho_brick'</span>, field_names{i}, complement_flag);
1109                 <span class="keyword">otherwise</span>
1110                     error([<span class="string">'Field name &quot;%s&quot; is not allowed for an ortho_brick!\nAllowed field names for an ortho_brick are: '</span> <span class="keyword">...</span>
1111                            <span class="string">'opposite_corner_a, opposite_corner_b, and complement_flag.'</span>], field_names{i});
1112             <span class="keyword">end</span>
1113         <span class="keyword">end</span>
1114         
1115         <span class="comment">% Start geo code with an opening parenthesis.</span>
1116         geo_code = <span class="string">'('</span>;
1117 
1118         <span class="comment">% Add geo code for each ortho_brick.</span>
1119         <span class="keyword">for</span> i = 1:n_ortho_bricks
1120             <span class="keyword">if</span> (complement_flag(i))
1121                 geo_code = [geo_code <span class="string">'not '</span>];
1122             <span class="keyword">end</span>
1123             
1124             geo_code = [geo_code sprintf(<span class="string">'orthobrick(%g, %g, %g ; %g, %g, %g)'</span>, <span class="keyword">...</span>
1125                         min([opposite_corner_a(:, i) opposite_corner_b(:, i)], [], 2), <span class="keyword">...</span>
1126                         max([opposite_corner_a(:, i) opposite_corner_b(:, i)], [], 2))];
1127                     
1128             <span class="keyword">if</span> (i &lt; n_ortho_bricks)
1129                 geo_code = [geo_code operator_string];
1130             <span class="keyword">else</span>
1131                 geo_code = [geo_code <span class="string">')'</span>];             
1132             <span class="keyword">end</span>
1133         <span class="keyword">end</span>
1134     <span class="keyword">end</span>
1135     
1136     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
1137     
1138 <a name="_sub18" href="#_subfunctions" class="code">function geo_code = parse_geometry_parallelepiped(parallelepiped, operator_string)</a>
1139 
1140     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
1141 
1142     <span class="keyword">if</span> (~isstruct(parallelepiped) || isempty(parallelepiped))
1143         error(<span class="string">'Parameter parallelepiped must be a valid structure.'</span>);        
1144     <span class="keyword">else</span>
1145         <span class="comment">% Get number of parallelepiped.</span>
1146         n_parallelepipeds = numel(parallelepiped);
1147         
1148         <span class="comment">% Get structure field names.</span>
1149         field_names = fieldnames(parallelepiped);
1150         n_fields = numel(field_names);
1151         
1152         <span class="comment">% Assign default values.</span>
1153         vertex          = [0;0;0]*ones(1, n_parallelepipeds);
1154         vector_a        = [1;0;0]*ones(1, n_parallelepipeds);
1155         vector_b        = [0;1;0]*ones(1, n_parallelepipeds);
1156         vector_c        = [0;0;1]*ones(1, n_parallelepipeds);
1157         complement_flag = zeros(1, n_parallelepipeds);
1158         
1159         <span class="comment">% Parse all structure fields.</span>
1160         <span class="keyword">for</span> i = 1:n_fields
1161             <span class="keyword">switch</span> (field_names{i})  
1162                 <span class="keyword">case</span> <span class="string">'vertex'</span>
1163                     vertex = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vertex);
1164                 <span class="keyword">case</span> <span class="string">'vector_a'</span>
1165                     vector_a = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vector_a);
1166                 <span class="keyword">case</span> <span class="string">'vector_b'</span>
1167                     vector_b = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vector_b);
1168                 <span class="keyword">case</span> <span class="string">'vector_c'</span>
1169                     vector_c = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, vector_c);
1170                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1171                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(parallelepiped, n_parallelepipeds, <span class="string">'parallelepiped'</span>, field_names{i}, complement_flag);
1172                 <span class="keyword">otherwise</span>
1173                     error([<span class="string">'Field name &quot;%s&quot; is not allowed for a parallelepiped!\nAllowed field names for a parallelepiped are: '</span> <span class="keyword">...</span>
1174                            <span class="string">'vertex, vector_a, vector_b, vector_c, and complement_flag.'</span>], field_names{i});
1175             <span class="keyword">end</span>
1176         <span class="keyword">end</span>
1177         
1178         <span class="comment">% Start geo code with an opening parenthesis.</span>
1179         geo_code = <span class="string">'('</span>;
1180 
1181         <span class="comment">% Add geo code for each parallelepiped.</span>
1182         <span class="keyword">for</span> i = 1:n_parallelepipeds
1183             <span class="keyword">if</span> (complement_flag(i))
1184                 geo_code = [geo_code <span class="string">'not '</span>];
1185             <span class="keyword">end</span>
1186              
1187             <span class="comment">% Make sure all vectors are not coplanar.</span>
1188             <span class="keyword">if</span> (abs(dot(vector_a(:,i), cross(vector_b(:,i), vector_c(:,i)))) &lt; eps)
1189                 error(<span class="string">'parallelepiped(%d) description includes coplanar vectors.'</span>, i);
1190             <span class="keyword">end</span>
1191             
1192             <span class="comment">% Compute opposite vertex.</span>
1193             opposite_vertex = vertex(:,i) + vector_a(:,i) + vector_b(:,i) + vector_c(:,i);
1194             
1195             <span class="comment">% Compute normal vectors.</span>
1196             n_vector_ab = cross(vector_a(:,i), vector_b(:,i));
1197             n_vector_ac = cross(vector_a(:,i), vector_c(:,i));
1198             n_vector_bc = cross(vector_b(:,i), vector_c(:,i));
1199             
1200             <span class="comment">% Check normal vectors directions.</span>
1201             <span class="keyword">if</span> (dot(n_vector_ab, vector_c(:,i)) &lt; 0)
1202                 n_vector_ab = -n_vector_ab;
1203             <span class="keyword">end</span>
1204             <span class="keyword">if</span> (dot(n_vector_ac, vector_b(:,i)) &lt; 0)
1205                 n_vector_ac = -n_vector_ac;
1206             <span class="keyword">end</span>
1207             <span class="keyword">if</span> (dot(n_vector_bc, vector_a(:,i)) &lt; 0)
1208                 n_vector_bc = -n_vector_bc;
1209             <span class="keyword">end</span>
1210             
1211             geo_code = [geo_code sprintf([<span class="string">'(plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1212                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1213                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1214                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1215                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g) and'</span> <span class="keyword">...</span>
1216                                           <span class="string">' plane(%g, %g, %g ; %g, %g, %g))'</span>], <span class="keyword">...</span>
1217                         vertex(:,i), -n_vector_ab, <span class="keyword">...</span>
1218                         vertex(:,i), -n_vector_ac, <span class="keyword">...</span>
1219                         vertex(:,i), -n_vector_bc, <span class="keyword">...</span>
1220                         opposite_vertex, n_vector_ab, <span class="keyword">...</span>
1221                         opposite_vertex, n_vector_ac, <span class="keyword">...</span>
1222                         opposite_vertex, n_vector_bc)];
1223                     
1224             <span class="keyword">if</span> (i &lt; n_parallelepipeds)
1225                 geo_code = [geo_code operator_string];
1226             <span class="keyword">else</span>
1227                 geo_code = [geo_code <span class="string">')'</span>];             
1228             <span class="keyword">end</span>
1229         <span class="keyword">end</span>
1230     <span class="keyword">end</span>
1231     
1232     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
1233     
1234 <a name="_sub19" href="#_subfunctions" class="code">function geo_code = parse_geometry_sphere(sphere, operator_string)</a>
1235 
1236     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; starting.'</span>, operator_string, 4);
1237 
1238     <span class="keyword">if</span> (~isstruct(sphere) || isempty(sphere))
1239         error(<span class="string">'Parameter sphere must be a valid structure.'</span>);        
1240     <span class="keyword">else</span>
1241         <span class="comment">% Get number of spheres.</span>
1242         n_spheres = numel(sphere);
1243         
1244         <span class="comment">% Get structure field names.</span>
1245         field_names = fieldnames(sphere);
1246         n_fields = numel(field_names);
1247   
1248         <span class="comment">% Assign default values.</span>
1249         radius          = ones(1, n_spheres);
1250         center          = [0;0;0]*ones(1, n_spheres);
1251         complement_flag = false(1, n_spheres);
1252         
1253         <span class="comment">% Parse all structure fields.</span>
1254         <span class="keyword">for</span> i = 1:n_fields
1255             <span class="keyword">switch</span> (field_names{i})
1256                 <span class="keyword">case</span> {<span class="string">'center'</span>, <span class="string">'centre'</span>}
1257                     center = <a href="#_sub3" class="code" title="subfunction point = assign_point(struct, n_structs, struct_name, field_name, default_value)">assign_point</a>(sphere, n_spheres, <span class="string">'sphere'</span>, field_names{i}, center);
1258                 <span class="keyword">case</span> <span class="string">'radius'</span>
1259                     radius = <a href="#_sub2" class="code" title="subfunction radius = assign_radius(struct, n_structs, struct_name, field_name, default_value)">assign_radius</a>(sphere, n_spheres, <span class="string">'sphere'</span>, field_names{i}, radius);     
1260                 <span class="keyword">case</span> <span class="string">'complement_flag'</span>
1261                     complement_flag = <a href="#_sub7" class="code" title="subfunction flag = assign_flag(struct, n_structs, struct_name, field_name, default_value)">assign_flag</a>(sphere, n_spheres, <span class="string">'sphere'</span>, field_names{i}, complement_flag);
1262                 <span class="keyword">otherwise</span>
1263                     error([<span class="string">'Field name ''%s'' is not valid for a sphere.\nAvailable field names for a sphere are: '</span> <span class="keyword">...</span>
1264                            <span class="string">'center, radius, and complement_flag.'</span>], field_names{i});
1265             <span class="keyword">end</span>
1266         <span class="keyword">end</span>
1267         
1268         <span class="comment">% Start geo code with an opening parenthesis.</span>
1269         geo_code = <span class="string">'('</span>;
1270 
1271         <span class="comment">% Add geo code for each sphere.</span>
1272         <span class="keyword">for</span> i = 1:n_spheres
1273             <span class="keyword">if</span> (complement_flag(i))
1274                 geo_code = [geo_code <span class="string">'not '</span>];
1275             <span class="keyword">end</span>
1276                 
1277             geo_code = [geo_code sprintf(<span class="string">'sphere(%g, %g, %g ; %g)'</span>, <span class="keyword">...</span>
1278                         center(:,i), radius(i))];
1279                     
1280             <span class="keyword">if</span> (i &lt; n_spheres)
1281                 geo_code = [geo_code operator_string];
1282             <span class="keyword">else</span>
1283                 geo_code = [geo_code <span class="string">')'</span>];             
1284             <span class="keyword">end</span>
1285         <span class="keyword">end</span>
1286     <span class="keyword">end</span>
1287     
1288     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ called with &quot;%s&quot; returning.'</span>, operator_string, 4);
1289                              
1290 <a name="_sub20" href="#_subfunctions" class="code">function write_geo_file(geo_fn, body_solid_code, electrode_solid_code, body_extra_code, electrode_extra_code, body_extra_param, electrode_extra_param)</a>
1291     
1292     <span class="comment">% Open geo file for writing.</span>
1293     fid = fopen(geo_fn, <span class="string">'w'</span>);
1294     
1295     <span class="keyword">if</span> (fid == -1)
1296         error(<span class="string">'Unable to open file %s for writing.'</span>, geo_fn);
1297     <span class="keyword">end</span>
1298     
1299     <span class="comment">% Write header for geo file.</span>
1300     fprintf(fid, <span class="string">'#Automatically generated by ng_mk_geometric_models\n\n'</span>);
1301     fprintf(fid, <span class="string">'algebraic3d\n\n'</span>);
1302     
1303     <span class="comment">% Assemble a string to represent the union of all bodies.</span>
1304     total_body_solid = <span class="string">'('</span>;
1305    
1306     <span class="keyword">for</span> i = 1:numel(body_solid_code)
1307         total_body_solid = [total_body_solid body_extra_param{i}.name];
1308 
1309         <span class="keyword">if</span> (i &lt; numel(body_solid_code))
1310             total_body_solid = [total_body_solid <span class="string">' or '</span>];
1311         <span class="keyword">else</span>
1312             total_body_solid = [total_body_solid <span class="string">')'</span>];             
1313         <span class="keyword">end</span>
1314     <span class="keyword">end</span>
1315     
1316     <span class="comment">% Assemble a string to represent the union of all electrodes entering the body.</span>
1317     total_electrode_solid = <span class="string">'('</span>;
1318     n_total_electrode_solid = 0;
1319    
1320     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1321         <span class="keyword">if</span> (electrode_extra_param{i}.enter_body_flag)
1322             <span class="keyword">if</span> (n_total_electrode_solid &gt; 0)
1323                 total_electrode_solid = [total_electrode_solid <span class="string">' or '</span>];
1324             <span class="keyword">end</span>
1325             total_electrode_solid = [total_electrode_solid electrode_extra_param{i}.name];
1326             n_total_electrode_solid = n_total_electrode_solid + 1;
1327         <span class="keyword">end</span>
1328     <span class="keyword">end</span>
1329     total_electrode_solid = [total_electrode_solid <span class="string">')'</span>];   
1330     
1331     <span class="comment">% Write body_extra_code and electrode_extra_code in geo file</span>
1332     <span class="keyword">for</span> i = 1:numel(body_extra_code)
1333         <span class="keyword">if</span> (~isempty(body_extra_code{i}))
1334             fprintf(fid, body_extra_code{i});
1335         <span class="keyword">end</span>
1336     <span class="keyword">end</span>
1337     <span class="keyword">for</span> i = 1:numel(electrode_extra_code)
1338         <span class="keyword">if</span> (~isempty(electrode_extra_code{i}))
1339             fprintf(fid, electrode_extra_code{i});
1340         <span class="keyword">end</span>
1341     <span class="keyword">end</span>
1342     fprintf(fid, <span class="string">'\n'</span>);
1343  
1344     <span class="comment">% Write electrode solids that enter the body in geo file.</span>
1345     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1346         <span class="keyword">if</span> (~isempty(electrode_solid_code{i}) &amp;&amp; electrode_extra_param{i}.enter_body_flag)
1347             fprintf(fid, <span class="string">'solid %s = %s;\n\n'</span>, electrode_extra_param{i}.name, electrode_solid_code{i});
1348         <span class="keyword">end</span>
1349     <span class="keyword">end</span>
1350     
1351     <span class="comment">% Write body solids in geo file.</span>
1352     <span class="keyword">for</span> i = 1:numel(body_solid_code)
1353         <span class="keyword">if</span> (n_total_electrode_solid == 0)
1354             fprintf(fid, <span class="string">'solid %s = %s;\n\n'</span>, body_extra_param{i}.name, body_solid_code{i});
1355         <span class="keyword">else</span>
1356             fprintf(fid, <span class="string">'solid %s = not %s and %s;\n\n'</span>, body_extra_param{i}.name, total_electrode_solid, body_solid_code{i});            
1357         <span class="keyword">end</span>
1358     <span class="keyword">end</span>
1359  
1360     <span class="comment">% Write electrode solids that do not enter the body in geo file.</span>
1361     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1362         <span class="keyword">if</span> (~isempty(electrode_solid_code{i}) &amp;&amp; ~electrode_extra_param{i}.enter_body_flag)
1363             fprintf(fid, <span class="string">'solid %s = not %s and %s;\n\n'</span>, electrode_extra_param{i}.name, total_body_solid, electrode_solid_code{i});
1364         <span class="keyword">end</span>
1365     <span class="keyword">end</span>
1366     
1367     <span class="comment">% Write electrode tlos in geo file.</span>
1368     <span class="keyword">for</span> i = 1:numel(electrode_solid_code)
1369         <span class="keyword">if</span> (~isempty(electrode_solid_code{i}))
1370             <span class="keyword">if</span> (isinf(electrode_extra_param{i}.max_edge_length))
1371                 fprintf(fid, <span class="string">'tlo %s -col=[1,0,0] -material=%s;\n'</span>, electrode_extra_param{i}.name, electrode_extra_param{i}.name);
1372             <span class="keyword">else</span>
1373                 fprintf(fid, <span class="string">'tlo %s -col=[1,0,0] -material=%s -maxh=%g;\n'</span>, electrode_extra_param{i}.name, electrode_extra_param{i}.name, electrode_extra_param{i}.max_edge_length);          
1374             <span class="keyword">end</span>
1375         <span class="keyword">end</span>
1376     <span class="keyword">end</span>
1377     
1378     <span class="comment">% Assume the first object is the main one</span>
1379     mainobj = <span class="string">'MainNetgenObject'</span>;
1380     fprintf(fid, <span class="string">'solid %s = %s '</span>, mainobj, body_extra_param{1}.name);
1381     <span class="keyword">for</span> i= 2:numel(body_solid_code)
1382        fprintf(fid, <span class="string">'and (not %s)'</span>, body_extra_param{i}.name);
1383     <span class="keyword">end</span>
1384     fprintf(fid, <span class="string">';\n'</span>);
1385     body_extra_param{1}.name = mainobj; <span class="comment">% rename it for following code</span>
1386      
1387     <span class="comment">% Write body tlos in geo file.</span>
1388     <span class="keyword">for</span> i = 1:numel(body_solid_code)
1389         <span class="keyword">if</span> (isinf(body_extra_param{i}.max_edge_length))
1390             fprintf(fid, <span class="string">'tlo %s -col=[0,1,0] -material=%s;\n'</span>, body_extra_param{i}.name, body_extra_param{i}.name);
1391         <span class="keyword">else</span>
1392             fprintf(fid, <span class="string">'tlo %s -col=[0,1,0] -material=%s -maxh=%g;\n'</span>, body_extra_param{i}.name, body_extra_param{i}.name, body_extra_param{i}.max_edge_length);            
1393         <span class="keyword">end</span>
1394     <span class="keyword">end</span>
1395     
1396     <span class="comment">% Close file.</span>
1397     fclose(fid);
1398 
1399 <a name="_sub21" href="#_subfunctions" class="code">function mat = read_mat_from_file(fid, nrows, ncols)</a>
1400     mat = fscanf(fid, <span class="string">'%g'</span>, [ncols, nrows])';
1401 
1402     <span class="comment">% Skip to next line.</span>
1403     <span class="keyword">if</span> (~isempty(fgetl(fid)))
1404         error(<span class="string">'Last line was only partialy read.'</span>);
1405     <span class="keyword">end</span>
1406     
1407 <a name="_sub22" href="#_subfunctions" class="code">function fmdl = read_vol_file(vol_fn, electrode_extra_param)</a>
1408 
1409     <span class="comment">% Open file for reading.</span>
1410     fid = fopen(vol_fn, <span class="string">'r'</span>);
1411 
1412     <span class="keyword">if</span> (fid == -1)
1413         error(<span class="string">'Unable to open file %s for reading.'</span>, vol_fn);
1414     <span class="keyword">end</span>
1415     
1416     <span class="comment">% Read a first line in vol file.</span>
1417     line = fgetl(fid);
1418    
1419     <span class="comment">% While no EOF or &quot;endmesh&quot; keyword is found.</span>
1420     <span class="keyword">while</span> (ischar(line) &amp;&amp; ~strcmp(line, <span class="string">'endmesh'</span>))
1421         
1422         <span class="comment">% Parse every line if not comment or empty line</span>
1423         <span class="keyword">if</span> (~isempty(line) &amp;&amp; line(1) ~= <span class="string">'#'</span>) <span class="comment">% Supposing '#' is always the first character of a comment line.</span>
1424             <span class="keyword">switch</span>(line)
1425                 <span class="keyword">case</span> <span class="string">'mesh3d'</span>   <span class="comment">% Nothing to do.</span>
1426                 <span class="keyword">case</span> <span class="string">'dimension'</span>
1427                     dimension = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1428                     <span class="keyword">if</span> (dimension ~= 3)
1429                         error(<span class="string">'unknown dimension %g in vol file.'</span>, dimension);
1430                     <span class="keyword">end</span>
1431                 <span class="keyword">case</span> <span class="string">'geomtype'</span>
1432                     geomtype = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1433                     <span class="keyword">if</span> (geomtype ~= 0)
1434                         error(<span class="string">'unknown %g geomtype in vol file.'</span>, geomtype);
1435                     <span class="keyword">end</span>
1436                 <span class="keyword">case</span> <span class="string">'surfaceelements'</span>
1437                     <span class="comment">% # surfnr    bcnr   domin  domout      np      p1      p2      p3</span>
1438                     n_surface_elements = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1439                     <span class="keyword">if</span> (n_surface_elements)
1440                         surface_elements   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_surface_elements, 8);
1441                     <span class="keyword">else</span>
1442                         error(<span class="string">'vol file contains no surface elements. There is probably something wrong with the provided geometry description.'</span>);    
1443                     <span class="keyword">end</span>
1444                 <span class="keyword">case</span> <span class="string">'volumeelements'</span>
1445                     <span class="comment">% #  matnr      np      p1      p2      p3      p4</span>
1446                     n_volume_elements = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1447                     <span class="keyword">if</span> (n_volume_elements)
1448                         volume_elements   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_volume_elements, 6);
1449                     <span class="keyword">else</span>
1450                         error(<span class="string">'vol file contains no volume elements. There is probably something wrong with the provided geometry description.'</span>);    
1451                     <span class="keyword">end</span>
1452                 <span class="keyword">case</span> <span class="string">'edgesegmentsgi2'</span>
1453                     <span class="comment">% # surfid  0   p1   p2   trignum1    trignum2   domin/surfnr1    domout/surfnr2   ednr1   dist1   ednr2   dist2</span>
1454                     n_edge_segments_sgi2 = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1455                     edge_segments_sgi2   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_edge_segments_sgi2, 12);
1456                 <span class="keyword">case</span> <span class="string">'points'</span>
1457                     <span class="comment">% #          X             Y             Z</span>
1458                     n_points = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1459                     <span class="keyword">if</span> (n_points)
1460                         points   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_points, 3);
1461                     <span class="keyword">else</span>
1462                         error(<span class="string">'vol file contains no points. There is probably something wrong with the provided geometry description.'</span>);                       
1463                     <span class="keyword">end</span>
1464                 <span class="keyword">case</span> <span class="string">'materials'</span>
1465                     n_materials = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1466                     <span class="keyword">if</span> (n_materials)
1467                         materials   = cell(n_materials, 2);
1468                         <span class="comment">% Read and parse each material line.</span>
1469                         <span class="keyword">for</span> i = 1:n_materials
1470                             material_line = fgetl(fid);
1471                             sscanf_result = sscanf(material_line, <span class="string">'%g%c%s'</span>)';
1472                             materials{i, 1} = sscanf_result(1);
1473                             materials{i, 2} = char(sscanf_result(3:end));
1474                         <span class="keyword">end</span>
1475                     <span class="keyword">else</span>
1476                         error(<span class="string">'vol file contains no materials. There is probably something wrong with the provided geometry description.'</span>);                             
1477                     <span class="keyword">end</span>
1478                 <span class="keyword">case</span> <span class="string">'face_colours'</span>
1479                     <span class="comment">% #   Surfnr     Red     Green     Blue</span>
1480                     n_face_colours = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, 1, 1);
1481                     face_colours   = <a href="#_sub21" class="code" title="subfunction mat = read_mat_from_file(fid, nrows, ncols)">read_mat_from_file</a>(fid, n_face_colours, 4);
1482                 <span class="keyword">otherwise</span>
1483                     error(<span class="string">'unknown &quot;%s&quot; line in vol file.'</span>, line);
1484             <span class="keyword">end</span>
1485         <span class="keyword">end</span>
1486         
1487         <span class="comment">% Read next line in vol file.</span>
1488         line = fgetl(fid);
1489     <span class="keyword">end</span>
1490     
1491     <span class="comment">% Close file.</span>
1492     fclose(fid);
1493     
1494     <span class="keyword">if</span> (~exist(<span class="string">'points'</span>, <span class="string">'var'</span>))
1495         error(<span class="string">'Point description is missing from vol file.'</span>);
1496     <span class="keyword">end</span>
1497  
1498     <span class="keyword">if</span> (~exist(<span class="string">'volume_elements'</span>, <span class="string">'var'</span>))
1499         error(<span class="string">'Volume element description is missing from vol file.'</span>);
1500     <span class="keyword">end</span>
1501     
1502     <span class="keyword">if</span> (~exist(<span class="string">'surface_elements'</span>, <span class="string">'var'</span>))
1503         error(<span class="string">'Surface element description is missing from vol file.'</span>);
1504     <span class="keyword">end</span>
1505     
1506     <span class="keyword">if</span> (~exist(<span class="string">'materials'</span>, <span class="string">'var'</span>))
1507         error(<span class="string">'Material description is missing from vol file.'</span>);
1508     <span class="keyword">end</span>
1509     
1510     <span class="comment">% Find electrode and body material indices.</span>
1511     electrode_material = [];
1512     <span class="keyword">for</span> i = 1:n_materials
1513         material_name   = materials{i, 2};
1514         material_number = materials{i, 1};
1515         
1516 <span class="comment">%         if (strncmp(material_name, 'electrode', 9))</span>
1517 <span class="comment">%             % Extract electrode number from material_name</span>
1518 <span class="comment">%             electrode_number = str2double(material_name(10:end));</span>
1519 <span class="comment">%             electrode_material(electrode_number) = material_number;</span>
1520 <span class="comment">%         end</span>
1521         <span class="keyword">for</span> j = 1:numel(electrode_extra_param)
1522             <span class="keyword">if</span> (strcmp(material_name, electrode_extra_param{j}.name))
1523                 electrode_material(j) = material_number;
1524             <span class="keyword">end</span>
1525         <span class="keyword">end</span>
1526     <span class="keyword">end</span>
1527    
1528     <span class="comment">% Remove electrode material if necessary</span>
1529     original_n_nodes     = size(points, 1);
1530     original_n_elements  = size(volume_elements, 1);
1531     original_n_surfaces  = size(surface_elements, 1);
1532     original_n_materials = size(materials, 1);
1533 
1534     <span class="keyword">for</span> i = 1:numel(electrode_material)
1535         <span class="keyword">if</span> (~electrode_extra_param{i}.keep_material_flag)
1536             <span class="comment">% Remove unwanted volume elements</span>
1537             volume_elements(volume_elements(:, 1) == electrode_material(i), :) = [];
1538 
1539             <span class="comment">% Remove unwanted surface elements</span>
1540             surface_elements(surface_elements(:, 3) == electrode_material(i) &amp; <span class="keyword">...</span>
1541                              surface_elements(:, 4) == 0 | <span class="keyword">...</span>
1542                              surface_elements(:, 4) == electrode_material(i) &amp; <span class="keyword">...</span>
1543                              surface_elements(:, 3) == 0, :) = [];
1544         <span class="keyword">end</span>
1545     <span class="keyword">end</span>
1546 
1547     <span class="comment">% Find nodes that are now unused.</span>
1548     unused_nodes = true(1, size(points, 1));
1549     unused_nodes(volume_elements(:, 3:6))  = false;
1550     unused_nodes(surface_elements(:, 6:8)) = false;     
1551 
1552     <span class="comment">% Remove unused points.</span>
1553     points(unused_nodes, :) = [];
1554 
1555     <span class="comment">% Compute new node indices after node removal.</span>
1556     new_node_index = (1:original_n_nodes) - cumsum(unused_nodes);   
1557 
1558     <span class="comment">% Update node indices for surface and volume elements.</span>
1559     surface_elements(:, 6:8) = new_node_index(surface_elements(:, 6:8));
1560     volume_elements(:, 3:6)  = new_node_index(volume_elements(:, 3:6));
1561 
1562     <span class="comment">% Find materials that are now unused.</span>
1563     unused_materials = true(1, size(materials, 1));
1564     unused_materials(volume_elements(:, 1)) = false;
1565 
1566     <span class="comment">% Remove unused materials.</span>
1567     materials(unused_materials, :) = [];
1568 
1569     <span class="comment">% Compute new material indices after material removal.</span>
1570     new_material_index = (1:original_n_materials) - cumsum(unused_materials);   
1571 
1572     <span class="comment">% Update material indices for volume elements.</span>
1573     volume_elements(:, 1)  = new_material_index(volume_elements(:, 1));
1574 
1575     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ Removed %d nodes, %d elements, %d surfaces and %d materials'</span>, <span class="keyword">...</span>
1576         original_n_nodes     - size(points, 1), <span class="keyword">...</span>
1577         original_n_elements  - size(volume_elements, 1), <span class="keyword">...</span>
1578         original_n_surfaces  - size(surface_elements, 1), <span class="keyword">...</span>
1579         original_n_materials - size(materials, 1), 3);
1580     
1581     <span class="comment">% Assign mesh data to fmdl structures.</span>
1582     fmdl.nodes            = points;
1583     fmdl.elems            = volume_elements(:, 3:6);
1584     fmdl.boundary         = surface_elements(:, 6:8);
1585     fmdl.boundary_numbers = surface_elements(:, 2);
1586     <span class="keyword">for</span> i=1:max(volume_elements(:,1))
1587        fmdl.mat_idx{i}    = find( volume_elements(:, 1) == i);
1588     <span class="keyword">end</span>
1589     fmdl.mat_name         = materials(:, 2);
1590     
1591     <span class="comment">% Find electrode surfaces and nodes.</span>
1592     <span class="keyword">for</span> i = 1:numel(electrode_material)
1593         <span class="comment">% Find surfaces that are part of the electrodes.</span>
1594         <span class="keyword">if</span> (electrode_extra_param{i}.keep_material_flag)
1595             electrode_boundary = <span class="keyword">...</span>
1596                sort(find(surface_elements(:, 3) == 0 &amp; <span class="keyword">...</span>
1597                          surface_elements(:, 4) == electrode_material(i) | <span class="keyword">...</span>
1598                          surface_elements(:, 4) == 0 &amp; <span class="keyword">...</span>
1599                          surface_elements(:, 3) == electrode_material(i)))';
1600         <span class="keyword">else</span>
1601             electrode_boundary = <span class="keyword">...</span>
1602                 sort(find(surface_elements(:, 3) == electrode_material(i) | <span class="keyword">...</span>
1603                           surface_elements(:, 4) == electrode_material(i)))';
1604         <span class="keyword">end</span>
1605      
1606         <span class="keyword">if</span> (isempty(electrode_boundary))
1607             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'WARNING: Electrode #%04d has been removed since it does not contact any body.'</span>, i, 2);
1608         <span class="keyword">else</span>
1609             fmdl.electrode(i).boundary = electrode_boundary;
1610             
1611             <span class="comment">% Find nodes that are part of the electrodes.</span>
1612             fmdl.electrode(i).nodes = <span class="keyword">...</span>
1613                 unique(fmdl.boundary(fmdl.electrode(i).boundary(:), :))';                          
1614 
1615             <span class="comment">% Assign default contact impedance.</span>
1616             fmdl.electrode(i).z_contact = 0.01;
1617             
1618             <span class="keyword">if</span> (~isempty(electrode_extra_param{i}.name))
1619                 fmdl.electrode(i).name = electrode_extra_param{i}.name;
1620             <span class="keyword">end</span>
1621         <span class="keyword">end</span>
1622     <span class="keyword">end</span>
1623 
1624 <a name="_sub23" href="#_subfunctions" class="code">function fmdl = complete_fmdl(fmdl, electrode_extra_param)</a>
1625  
1626     <span class="comment">% Find center point of domain.</span>
1627     domain_center  = (max(fmdl.nodes)-min(fmdl.nodes))/2 + min(fmdl.nodes);
1628     domain_centers = ones(size(fmdl.nodes, 1), 1)*domain_center;
1629     
1630     <span class="comment">% Find node closest to center for ground node.</span>
1631     [unused, min_idx] = min(sum((fmdl.nodes - domain_centers).^2, 2));
1632     fmdl.gnd_node     = min_idx(1);
1633 
1634     fmdl.np_fwd_solve.perm_sym = <span class="string">'{n}'</span>;
1635 
1636     fmdl.name = <span class="string">'ng_mk_geometric_models'</span>;
1637 
1638     fmdl.solve=      <span class="string">'eidors_default'</span>;
1639     fmdl.jacobian=   <span class="string">'eidors_default'</span>;
1640     fmdl.system_mat= <span class="string">'eidors_default'</span>;
1641 
1642     fmdl.normalize_measurements = 0;
1643     
1644     <span class="keyword">for</span> i = 1:numel(electrode_extra_param)
1645         <span class="keyword">if</span> (isfield(electrode_extra_param{i}, <span class="string">'point'</span>))
1646             <span class="comment">% Find center point of domain.</span>
1647             electrode_points = ones(size(fmdl.nodes, 1), 1)*electrode_extra_param{i}.point';
1648 
1649             <span class="comment">% Find node closest to the electrode point.</span>
1650             [unused, min_idx]       = min(sum((fmdl.nodes - electrode_points).^2, 2));
1651             fmdl.electrode(i).nodes = min_idx(1);
1652             fmdl.electrode(i).boundary = [];
1653 
1654             <span class="comment">% Assign default contact impedance.</span>
1655             fmdl.electrode(i).z_contact = 0.01;
1656         <span class="keyword">end</span>
1657     <span class="keyword">end</span>
1658 
1659     fmdl = <a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>, fmdl);
1660 
1661 <a name="_sub24" href="#_subfunctions" class="code">function do_unit_test</a>
1662     <span class="keyword">for</span> tn = 1:<a href="#_sub25" class="code" title="subfunction [fmdl, opts] = do_test_number(tn)">do_test_number</a>(0)
1663         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'ng_mk_geometric_models: unit_test %02d'</span>, tn, 1);
1664         [fmdl, opts] = <a href="#_sub25" class="code" title="subfunction [fmdl, opts] = do_test_number(tn)">do_test_number</a>(tn);
1665         subplot(1,3,1)
1666         <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl);
1667         title(<span class="string">'show_fem'</span>, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
1668         subplot(1,3,2);
1669         <a href="../../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>(fmdl, opts);
1670         title({<span class="string">'show_fem_enhanced'</span>; <span class="string">'(default options)'</span>}, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
1671         subplot(1,3,3);
1672         opts.edge.color = [0 0 1];
1673         opts.edge.width = 0;
1674         opts.edge.significant.color = [1 0 0];
1675         opts.edge.significant.width = 1.5;
1676         opts.edge.significant.viewpoint_dependent.color = [0 1 0];
1677         opts.edge.significant.viewpoint_dependent.width = 1.5;
1678         <a href="../../../eidors/graphics/matlab/show_fem_enhanced.html" class="code" title="function hh = show_fem(mdl, options)">show_fem_enhanced</a>(fmdl, opts);
1679         title({<span class="string">'show_fem_enhanced'</span>; <span class="string">'(with some options)'</span>}, <span class="string">'Interpreter'</span>, <span class="string">'none'</span>, <span class="string">'FontWeight'</span>, <span class="string">'bold'</span>);
1680         drawnow;
1681         <span class="comment">%pause</span>
1682     <span class="keyword">end</span>
1683 
1684 <a name="_sub25" href="#_subfunctions" class="code">function [fmdl, opts] = do_test_number(tn)</a>
1685     opts = struct;
1686     <span class="keyword">switch</span> tn
1687         <span class="comment">% Simple 3D cylinder. Radius = 1 with no electrodes</span>
1688         <span class="keyword">case</span> 1;
1689             body_geometry.cylinder = struct;
1690             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1691         <span class="comment">% Simple 3D cylinder. Radius = 1 with 16 spherical electrodes.</span>
1692         <span class="keyword">case</span> 2;
1693             body_geometry.cylinder = struct;
1694             n_elect = 16;
1695             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1696             <span class="keyword">for</span> i = 1:n_elect
1697                 electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
1698                 electrode_geometry{i}.sphere.radius = 0.1;
1699             <span class="keyword">end</span>
1700             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1701         <span class="comment">% Simple 3D cylinder. Radius = 1 with 16 cylindrical electrodes.</span>
1702         <span class="keyword">case</span> 3;
1703             body_geometry.cylinder = struct;
1704             n_elect = 16;
1705             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1706             <span class="keyword">for</span> i = 1:n_elect
1707                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1708                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1709                 electrode_geometry{i}.cylinder.radius = 0.1;
1710             <span class="keyword">end</span>
1711             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1712         <span class="keyword">case</span> 4;
1713             body_geometry.cylinder = struct;
1714             n_elect = 16;
1715             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1716             <span class="keyword">for</span> i = 1:n_elect
1717                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1718                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1719                 electrode_geometry{i}.cylinder.radius = 0.1;
1720                 electrode_geometry{i}.keep_material_flag = 1;
1721             <span class="keyword">end</span>
1722             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1723         <span class="keyword">case</span> 5;
1724             body_geometry.cylinder = struct;
1725             n_elect = 16;
1726             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1727             <span class="keyword">for</span> i = 1:n_elect
1728                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1729                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1730                 electrode_geometry{i}.cylinder.radius = 0.1;
1731                 electrode_geometry{i}.enter_body_flag = 1;
1732             <span class="keyword">end</span>
1733             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1734         <span class="keyword">case</span> 6;
1735             body_geometry.cylinder = struct;
1736             n_elect = 16;
1737             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1738             <span class="keyword">for</span> i = 1:n_elect
1739                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1740                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1741                 electrode_geometry{i}.cylinder.radius = 0.1;
1742                 electrode_geometry{i}.keep_material_flag = 1;
1743                 electrode_geometry{i}.enter_body_flag = 1;                
1744             <span class="keyword">end</span>
1745             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1746         <span class="keyword">case</span> 7;
1747             body_geometry.cylinder = struct;
1748             body_geometry.sphere.center = [0 0 1];
1749             n_elect = 16;
1750             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1751             <span class="keyword">for</span> i = 1:n_elect
1752                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1753                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1754                 electrode_geometry{i}.cylinder.radius = 0.1;
1755             <span class="keyword">end</span>
1756             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1757         <span class="keyword">case</span> 8;
1758             body_geometry.cylinder  = struct;
1759             body_geometry.sphere(1) = struct;  
1760             body_geometry.sphere(2).center = [0 0 1];         
1761             n_elect = 16;
1762             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1763             <span class="keyword">for</span> i = 1:n_elect
1764                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1765                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1766                 electrode_geometry{i}.cylinder.radius = 0.1;
1767             <span class="keyword">end</span>
1768             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);   
1769         <span class="keyword">case</span> 9;
1770             body_geometry.intersection.cylinder(1) = struct;
1771             body_geometry.intersection.cylinder(2).radius     = 0.5;
1772             body_geometry.intersection.cylinder(2).complement_flag = 1;   
1773             n_elect = 16;
1774             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1775             <span class="keyword">for</span> i = 1:n_elect
1776                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1777                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1778                 electrode_geometry{i}.cylinder.radius = 0.1;
1779             <span class="keyword">end</span>
1780             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1781         <span class="keyword">case</span> 10;
1782             body_geometry.intersection(1).sphere(1).radius     = 0.5;
1783             body_geometry.intersection(1).sphere(1).center     = [0 0 2];
1784             body_geometry.intersection(1).sphere(1).complement_flag = 1;
1785             body_geometry.intersection(1).sphere(2).center     = [0 0 2];
1786             body_geometry.intersection(2).cylinder(1).top_center = [0 0 2];
1787             body_geometry.intersection(2).cylinder(2).radius     = 0.5;
1788             body_geometry.intersection(2).cylinder(2).top_center = [0 0 2];
1789             body_geometry.intersection(2).cylinder(2).complement_flag = 1;   
1790             n_elect = 16;
1791             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1792             <span class="keyword">for</span> i = 1:n_elect
1793                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1794                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1795                 electrode_geometry{i}.cylinder.radius = 0.1;
1796             <span class="keyword">end</span>
1797             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1798         <span class="keyword">case</span> 11;
1799             body_geometry.intersection.union(1).sphere.radius = 0.5;
1800             body_geometry.intersection.union(1).sphere.center = [0 0 2];
1801             body_geometry.intersection.union(1).cylinder.radius = 0.5;
1802             body_geometry.intersection.union(1).cylinder.top_center = [0 0 2];
1803             body_geometry.intersection.union(1).complement_flag = 1;
1804             body_geometry.intersection.union(2).sphere.center = [0 0 2];
1805             body_geometry.intersection.union(2).cylinder.top_center = [0 0 2]; 
1806             n_elect = 16;
1807             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1808             <span class="keyword">for</span> i = 1:n_elect
1809                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1810                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1811                 electrode_geometry{i}.cylinder.radius = 0.1;
1812             <span class="keyword">end</span>
1813             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1814         <span class="keyword">case</span> 12;
1815             body_geometry.cone = struct; 
1816             n_elect = 16;
1817             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1818             <span class="keyword">for</span> i = 1:n_elect
1819                 electrode_geometry{i}.cylinder.top_center    = [0.85*cos(theta(i)) 0.85*sin(theta(i)) 0.5];
1820                 electrode_geometry{i}.cylinder.bottom_center = [0.65*cos(theta(i)) 0.65*sin(theta(i)) 0.5];
1821                 electrode_geometry{i}.cylinder.radius = 0.1;
1822             <span class="keyword">end</span>
1823             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1824         <span class="keyword">case</span> 13;
1825             body_geometry.cone = struct; 
1826             n_elect = 16;
1827             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1828             <span class="keyword">for</span> i = 1:n_elect
1829                 electrode_geometry{i}.sphere.center = [0.75*cos(theta(i)) 0.75*sin(theta(i)) 0.5];
1830                 electrode_geometry{i}.sphere.radius = 0.1;
1831             <span class="keyword">end</span>
1832             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1833         <span class="keyword">case</span> 14;
1834             body_geometry.cone(1).top_center = [0 0 1.5];
1835             body_geometry.cone(1).bottom_center = [0 0 0.5];
1836             body_geometry.cone(2).top_center = [0 0 -1.5];
1837             body_geometry.cone(2).bottom_center = [0 0 -0.5];
1838             body_geometry.cylinder.top_center    = [0, 0, 0.5];
1839             body_geometry.cylinder.bottom_center = [0, 0, -0.5];
1840             n_elect = 16;
1841             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1842             <span class="keyword">for</span> i = 1:n_elect
1843                 electrode_geometry{i}.sphere.center = [0.75*cos(theta(i)) 0.75*sin(theta(i)) 1.0];
1844                 electrode_geometry{i}.sphere.radius = 0.1;
1845                 electrode_geometry{i + n_elect}.sphere.center = [cos(theta(i)) sin(theta(i)) 0];
1846                 electrode_geometry{i + n_elect}.sphere.radius = 0.15;
1847                 electrode_geometry{i + 2*n_elect}.sphere.center = [0.75*cos(theta(i)) 0.75*sin(theta(i)) -1.0];
1848                 electrode_geometry{i + 2*n_elect}.sphere.radius = 0.1;
1849             <span class="keyword">end</span>
1850             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1851             opts.edge.significant.angle = 15;
1852         <span class="keyword">case</span> 15
1853             body_geometry.ortho_brick = struct;
1854             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1855         <span class="keyword">case</span> 16
1856             body_geometry.intersection.ortho_brick.opposite_corner_a = [0 0 0];
1857             body_geometry.intersection.ortho_brick.opposite_corner_b = [5 5 4];
1858             <span class="keyword">for</span> i = 1:4; 
1859                 <span class="keyword">for</span> j = 1:4; 
1860                     body_geometry.intersection.cylinder(i,j).radius = 0.15;
1861                     body_geometry.intersection.cylinder(i,j).top_center = [i, j, 4];
1862                     body_geometry.intersection.cylinder(i,j).bottom_center = [i, j, 2];
1863                     body_geometry.intersection.cylinder(i,j).complement_flag = 1;
1864                 <span class="keyword">end</span>; 
1865             <span class="keyword">end</span>;
1866             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);    
1867         <span class="keyword">case</span> 17
1868             body_geometry.intersection.ortho_brick.opposite_corner_a = [0 0 0];
1869             body_geometry.intersection.ortho_brick.opposite_corner_b = [5 5 4];
1870             <span class="keyword">for</span> i = 1:4; 
1871                 <span class="keyword">for</span> j = 1:4; 
1872                     body_geometry.intersection.cylinder(i, j).radius = 0.15;
1873                     body_geometry.intersection.cylinder(i, j).top_center    = [i, j, 4];
1874                     body_geometry.intersection.cylinder(i, j).bottom_center = [i, j, 2];
1875                     body_geometry.intersection.cylinder(i, j).complement_flag = 1;
1876                     electrode_geometry{i, j, 1}.cylinder.radius        = 0.2;
1877                     electrode_geometry{i, j, 1}.cylinder.top_center    = [i, j, 3.1];
1878                     electrode_geometry{i, j, 1}.cylinder.bottom_center = [i, j, 2.9];
1879                     electrode_geometry{i, j, 2}.cylinder.radius        = 0.2;
1880                     electrode_geometry{i, j, 2}.cylinder.top_center    = [i, j, 2.2];
1881                     electrode_geometry{i, j, 2}.cylinder.bottom_center = [i, j, 2.0];
1882                 <span class="keyword">end</span>; 
1883             <span class="keyword">end</span>;
1884             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1885         <span class="keyword">case</span> 18
1886             body_geometry.parallelepiped  = struct;
1887             body_geometry.max_edge_length = 0.15;
1888             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1889         <span class="keyword">case</span> 19
1890             body_geometry.parallelepiped.vertex   = [ 0;  0;  0];
1891             body_geometry.parallelepiped.vector_a = [ 1;  1;  0];
1892             body_geometry.parallelepiped.vector_b = [ 0;  1;  1];
1893             body_geometry.parallelepiped.vector_c = [ 1;  0;  1];
1894             body_geometry.max_edge_length = 0.15;
1895             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1896         <span class="keyword">case</span> 20
1897             body_geometry.intersection.ortho_brick.opposite_corner_a = [-15, -15, 0];
1898             body_geometry.intersection.ortho_brick.opposite_corner_b = [15, 15, 5];
1899             body_geometry.intersection.half_space.point = [0, 0, 5];
1900             body_geometry.intersection.half_space.outward_normal_vector = [-1, -1, 5];
1901             
1902             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1903         <span class="keyword">case</span> 21
1904             body_geometry.ellipsoid.axis_a = [1 0 0];
1905             body_geometry.ellipsoid.axis_b = [0 2 0];
1906             body_geometry.ellipsoid.axis_c = [0 0 3];
1907             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);   
1908         <span class="keyword">case</span> 22
1909             body_geometry.ellipsoid.axis_a = [1 0 0];
1910             body_geometry.ellipsoid.axis_b = [0 1 1];
1911             body_geometry.ellipsoid.axis_c = [0 -2 2];
1912             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);   
1913         <span class="keyword">case</span> 23
1914             body_geometry.elliptic_cylinder.top_center = [0, 0, 10];
1915             body_geometry.elliptic_cylinder.bottom_center = [0, 0, 0];           
1916             body_geometry.elliptic_cylinder.axis_a = [1 0 0];
1917             body_geometry.elliptic_cylinder.axis_b = [0 2 0];  
1918             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1919         <span class="keyword">case</span> 24
1920             body_geometry.elliptic_cylinder.top_center = [0, 5, 5];
1921             body_geometry.elliptic_cylinder.bottom_center = [0, 0, 0];           
1922             body_geometry.elliptic_cylinder.axis_a = [1 0 0];
1923             body_geometry.elliptic_cylinder.axis_b = [0 -2 2];  
1924             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1925         <span class="keyword">case</span> 25
1926             body_geometry.body_of_revolution = struct;
1927             body_geometry.max_edge_length = 0.15;
1928             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1929         <span class="keyword">case</span> 26
1930             body_geometry.body_of_revolution.points   = [1 1; 1 2; 2 1.5; 2 1];
1931             body_geometry.body_of_revolution.segments = [1 2; 2 3; 3 4; 4 1];
1932             body_geometry.max_edge_length = 0.15;
1933             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1934         <span class="keyword">case</span> 27
1935             n_points = 24;
1936             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];
1937             body_geometry.body_of_revolution.points   = 2 + [sin(theta) cos(theta)];
1938             body_geometry.body_of_revolution.segments = [(1:n_points)' [(2:n_points) 1]'];
1939             body_geometry.max_edge_length = 0.15;
1940             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1941         <span class="keyword">case</span> 28
1942             n_points = 24;
1943             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];
1944             body_geometry.body_of_revolution.points   = 2 + [sin(theta) cos(theta)];
1945             body_geometry.body_of_revolution.segments = [(1:2:n_points)' (2:2:n_points)' [(3:2:n_points) 1]'];
1946             body_geometry.max_edge_length = 0.15;
1947             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
1948         <span class="keyword">case</span> 29
1949             body_geometry{1}.cylinder(1).radius        = 0.5;
1950             body_geometry{1}.cylinder(1).top_center    = [0 0 0.75];
1951             body_geometry{1}.cylinder(1).bottom_center = [0 0 0.25];
1952             body_geometry{1}.name                      = <span class="string">'Object'</span>;           
1953             body_geometry{2}.cylinder(2).radius        = 1;
1954             body_geometry{2}.name                      = <span class="string">'Tank'</span>;
1955             n_elect = 16;
1956             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1957             <span class="keyword">for</span> i = 1:n_elect
1958                 electrode_geometry{i}.cylinder.top_center    = [1.03*cos(theta(i)) 1.03*sin(theta(i)) 0.5];
1959                 electrode_geometry{i}.cylinder.bottom_center = [0.97*cos(theta(i)) 0.97*sin(theta(i)) 0.5];
1960                 electrode_geometry{i}.cylinder.radius = 0.1;
1961             <span class="keyword">end</span>
1962             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1963         <span class="keyword">case</span> 30
1964             body_geometry{1}.sphere.radius     = 0.25;
1965             body_geometry{1}.sphere.center     = [0 0 0.5];
1966             body_geometry{1}.name              = <span class="string">'Sphere'</span>;
1967             body_geometry{2}.cylinder.radius   = 1;
1968             body_geometry{2}.name              = <span class="string">'Tank'</span>;           
1969             n_elect = 16;
1970             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1971             <span class="keyword">for</span> i = 1:n_elect
1972                 electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
1973                 electrode_geometry{i}.sphere.radius = 0.1;
1974             <span class="keyword">end</span>
1975             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1976        <span class="keyword">case</span> 31
1977             n_sphere = 8;
1978             theta = linspace(0, 2*pi, n_sphere+1); theta(end) = [];   
1979             <span class="keyword">for</span> i = 1:n_sphere
1980                 body_geometry{i}.sphere.radius   = 0.2;
1981                 body_geometry{i}.sphere.center   = [0.65*cos(theta(i)) 0.65*sin(theta(i)) 0.5];  
1982                 body_geometry{i}.max_edge_length = 0.025*(1 + rem(i,2));
1983                 body_geometry{i}.name            = sprintf(<span class="string">'Sphere%d'</span>, i);  
1984             <span class="keyword">end</span>        
1985             body_geometry{n_sphere+1}.cylinder.radius = 1;
1986             body_geometry{n_sphere+1}.name            = <span class="string">'Tank'</span>;  
1987             n_elect = 16;
1988             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1989             <span class="keyword">for</span> i = 1:n_elect
1990                 electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
1991                 electrode_geometry{i}.sphere.radius = 0.1;
1992                 electrode_geometry{i}.max_edge_length = 0.025*(1 + rem(i,2));
1993             <span class="keyword">end</span>
1994             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
1995        <span class="keyword">case</span> 32
1996             body_geometry.cylinder = struct;
1997             n_elect = 16;
1998             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
1999             <span class="keyword">for</span> i = 1:n_elect
2000                 electrode_geometry{i}.point = [cos(theta(i)) sin(theta(i)) 0.5];
2001             <span class="keyword">end</span>
2002             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
2003        <span class="keyword">case</span> 33     
2004             body_geometry.cylinder = struct;
2005             n_elect = 16;
2006             theta = linspace(0, 2*pi, n_elect+1); theta(end) = [];
2007             <span class="keyword">for</span> i = 1:n_elect
2008                 <span class="keyword">if</span> (rem(i,2))
2009                     electrode_geometry{i}.point = [cos(theta(i)) sin(theta(i)) 0.5];
2010                     electrode_geometry{i}.name  = sprintf(<span class="string">'Point_Electrode%d'</span>, ceil(i/2));
2011                 <span class="keyword">else</span>
2012                     electrode_geometry{i}.sphere.center = [cos(theta(i)) sin(theta(i)) 0.5];
2013                     electrode_geometry{i}.sphere.radius = 0.1;
2014                     electrode_geometry{i}.name          = sprintf(<span class="string">'Circular_Electrode%d'</span>, floor(i/2));
2015                 <span class="keyword">end</span>
2016             <span class="keyword">end</span>
2017             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry, electrode_geometry);
2018        <span class="keyword">case</span> 34
2019             body_geometry.body_of_extrusion = struct;
2020             body_geometry.max_edge_length = 0.15;
2021             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
2022         <span class="keyword">case</span> 35
2023             body_geometry.body_of_extrusion.path_points   = [0 0 0; 0.25 0 1; 0.25 0 2; 0.25 0 3; 0 0 4];
2024             body_geometry.body_of_extrusion.path_segments = [1 2; 2 3; 3 4; 4 5];
2025             body_geometry.max_edge_length = 0.15;
2026             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry);
2027        <span class="keyword">case</span> 36
2028             n_points = 16;
2029             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];
2030             body_geometry.body_of_extrusion.profile_points   = 0.2*(2 + [0.75*sin(theta) cos(theta)]);
2031             body_geometry.body_of_extrusion.profile_segments = [(1:n_points)' [(2:n_points) 1]'];
2032             n_points = 32;
2033             theta = linspace(0, 2*pi, n_points+1)'; theta(end) = [];          
2034             body_geometry.body_of_extrusion.path_points   = 1*(2 + [sin(theta) 1.5*cos(theta) zeros(n_points, 1)]);
2035             body_geometry.body_of_extrusion.path_segments = [(1:n_points)' [(2:n_points) 1]'];
2036             body_geometry.body_of_extrusion.vector_d      = [0; 0; 1];
2037             body_geometry.max_edge_length = 0.15;
2038             fmdl = <a href="ng_mk_geometric_models.html" class="code" title="function [fmdl, mat_idx] = ng_mk_geometric_models(body_geometry, electrode_geometry)">ng_mk_geometric_models</a>(body_geometry); 
2039         <span class="keyword">case</span> 0; fmdl = 36; <span class="comment">% Return maximum number of tests.</span>
2040         <span class="keyword">otherwise</span>;
2041             error(<span class="string">'Invalid test number.'</span>)
2042     <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>