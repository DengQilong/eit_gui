<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fwd_model_parameters</title>
  <meta name="keywords" content="fwd_model_parameters">
  <meta name="description" content="FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; fwd_model_parameters.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fwd_model_parameters
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function param = fwd_model_parameters( fwd_model, opt ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)
   Internal function to extract parameters from a fwd_model
   param.n_elem     =&gt; number of elements
   param.n_elec     =&gt; number of electrodes
   param.n_node     =&gt; number of nodes (vertices)
   param.n_stim     =&gt; number of current stimulation patterns
   param.n_elec     =&gt; number of electrodes
   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)
   param.n_meas     =&gt; number of measurements (total)
   param.boundary   =&gt; FEM boundary
   param.NODE       =&gt; vertex matrix
   param.ELEM       =&gt; connection matrix
   param.QQ         =&gt; Current into each NODE (Neuman Boundary Conditions)
   param.VV         =&gt; Voltage driven into each NODE (Dirichlet BC - only where QQ is NaN)
   param.YY         =&gt; Output Admittance (1/Impedance) of each node current (for each value in QQ)
   param.VOLUME     =&gt; Volume (or area) of each element
   param.normalize  =&gt; difference measurements normalized?
   param.N2E        =&gt; Node to electrode converter

 If the stimulation patterns has a 'interior_sources' field,
   the node current QQ, is set to this value for this stimulation.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>	FIND_ELECTRODE_BDY: find the boundary index area for electrode</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>	AA_FWD_PARAMETERS: data= aa_fwd_solve( fwd_model, image)</li><li><a href="../../../eidors/deprecated/exponential_covar_prior.html" class="code" title="function Reg= exponential_covar_prior( inv_model );">exponential_covar_prior</a>	EXPONENTIAL_COVAR_PRIOR image prior with exponential</li><li><a href="../../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/graphics/matlab/show_slices_move.html" class="code" title="function show_slices_move( img, move, move_scale )">show_slices_move</a>	SHOW_SLICES_MOVE   Shows planar slices of a 3D FEM with movement vectors</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>	FWD_SOLVE_2P5D_1ST_ORDER: data= fwd_solve_2p5d_1st_order( img)</li><li><a href="fwd_solve_halfspace.html" class="code" title="function data = fwd_solve_halfspace(fwd_model, img)">fwd_solve_halfspace</a>	FWD_SOLVE_HALFSPACE: data = fwd_solve_halfspace(img)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="jacobian_movement_halfspace.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_halfspace</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="system_mat_2p5d_fields.html" class="code" title="function FT= system_mat_2p5d_fields( fwd_model )">system_mat_2p5d_fields</a>	SYSTEM_MAT_2P5D_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="update_system_mat_fields.html" class="code" title="function FC1 = update_system_mat_fields( fwd_model0, fwd_model1 )">update_system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../../eidors/solvers/inverse/inv_solve_backproj.html" class="code" title="function img= inv_solve_backproj( inv_model, data1, data2)">inv_solve_backproj</a>	INV_SOLVE_BACKPROJ inverse solver using backprojection</li><li><a href="../../../eidors/solvers/inverse/inv_solve_conj_grad.html" class="code" title="function img= inv_solve_conj_grad( inv_model, data1, data2)">inv_solve_conj_grad</a>	INV_SOLVE_CONJ_GRAD inverse solver based on the CG</li><li><a href="../../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="../../../eidors/solvers/inverse/inv_solve_diff_kalman.html" class="code" title="function img= inv_solve_diff_kalman( inv_model, data1, data2)">inv_solve_diff_kalman</a>	INV_SOLVE_DIFF_KALMAN inverse solver for difference EIT</li><li><a href="../../../eidors/solvers/inverse/prior_exponential_covar.html" class="code" title="function Reg= prior_exponential_covar( inv_model );">prior_exponential_covar</a>	PRIOR_EXPONENTIAL_COVAR image prior with exponential</li><li><a href="../../../eidors/solvers/inverse/prior_laplace_old.html" class="code" title="function Reg= prior_laplace_old( inv_model );">prior_laplace_old</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_time_smooth.html" class="code" title="function Reg= prior_time_smooth( inv_model );">prior_time_smooth</a>	PRIOR_TIME_SMOOTH calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function pp= calc_param( fwd_model, opt )</a></li><li><a href="#_sub2" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a></li><li><a href="#_sub3" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a></li><li><a href="#_sub4" class="code">function [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)</a></li><li><a href="#_sub5" class="code">function [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function param = fwd_model_parameters( fwd_model, opt )</a>
0002 <span class="comment">% FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</span>
0003 <span class="comment">%   Internal function to extract parameters from a fwd_model</span>
0004 <span class="comment">%   param.n_elem     =&gt; number of elements</span>
0005 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0006 <span class="comment">%   param.n_node     =&gt; number of nodes (vertices)</span>
0007 <span class="comment">%   param.n_stim     =&gt; number of current stimulation patterns</span>
0008 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0009 <span class="comment">%   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)</span>
0010 <span class="comment">%   param.n_meas     =&gt; number of measurements (total)</span>
0011 <span class="comment">%   param.boundary   =&gt; FEM boundary</span>
0012 <span class="comment">%   param.NODE       =&gt; vertex matrix</span>
0013 <span class="comment">%   param.ELEM       =&gt; connection matrix</span>
0014 <span class="comment">%   param.QQ         =&gt; Current into each NODE (Neuman Boundary Conditions)</span>
0015 <span class="comment">%   param.VV         =&gt; Voltage driven into each NODE (Dirichlet BC - only where QQ is NaN)</span>
0016 <span class="comment">%   param.YY         =&gt; Output Admittance (1/Impedance) of each node current (for each value in QQ)</span>
0017 <span class="comment">%   param.VOLUME     =&gt; Volume (or area) of each element</span>
0018 <span class="comment">%   param.normalize  =&gt; difference measurements normalized?</span>
0019 <span class="comment">%   param.N2E        =&gt; Node to electrode converter</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% If the stimulation patterns has a 'interior_sources' field,</span>
0022 <span class="comment">%   the node current QQ, is set to this value for this stimulation.</span>
0023 
0024 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0025 <span class="comment">% $Id: fwd_model_parameters.m 5457 2017-05-03 00:34:26Z aadler $</span>
0026 
0027 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model, <span class="string">'UNIT_TEST'</span>); <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0028 
0029 <span class="keyword">if</span> nargin &lt; 2
0030    opt.skip_VOLUME = 0;
0031 <span class="keyword">else</span>
0032    assert(ischar(opt),<span class="string">'opt must be a string'</span>);
0033    assert(strcmp(opt,<span class="string">'skip_VOLUME'</span>),<span class="string">'opt can only be ''skip_VOLUME'''</span>);
0034    opt = struct;
0035    opt.skip_VOLUME = 1;
0036 <span class="keyword">end</span>
0037 
0038 copt.fstr = <span class="string">'fwd_model_parameters'</span>;
0039 copt.log_level = 4;
0040 
0041 param = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction pp= calc_param( fwd_model, opt )">calc_param</a>,{fwd_model, opt},copt);
0042 
0043 
0044 <span class="comment">% perform actual parameter calculation</span>
0045 <a name="_sub1" href="#_subfunctions" class="code">function pp= calc_param( fwd_model, opt )</a>
0046 
0047 pp.NODE= fwd_model.nodes';
0048 pp.ELEM= fwd_model.elems';
0049 
0050 n= size(pp.NODE,2);        <span class="comment">%NODEs</span>
0051 d= size(pp.ELEM,1);        <span class="comment">%dimentions+1</span>
0052 e= size(pp.ELEM,2);        <span class="comment">%ELEMents</span>
0053 <span class="keyword">try</span>
0054    p = length(fwd_model.stimulation );
0055 <span class="keyword">catch</span> 
0056    p = 0;
0057 <span class="keyword">end</span>
0058 <span class="keyword">try</span>
0059    n_elec= length( fwd_model.electrode );
0060 <span class="keyword">catch</span>
0061    n_elec= 0;
0062    fwd_model.electrode = [];
0063 <span class="keyword">end</span>
0064 
0065 <span class="keyword">if</span> ~opt.skip_VOLUME
0066    copt.fstr = <span class="string">'element_volume'</span>;
0067    copt.log_level = 4;
0068    pp.VOLUME= <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub2" class="code" title="subfunction VOLUME = element_volume( NODE, ELEM, e, d)">element_volume</a>, {pp.NODE, pp.ELEM, e, d}, copt );
0069 <span class="keyword">end</span>
0070 
0071 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'boundary'</span>)
0072     bdy = double( fwd_model.boundary ); <span class="comment">% double because of stupid matlab bugs</span>
0073 <span class="keyword">else</span>
0074     bdy = <a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(fwd_model.elems);
0075 <span class="keyword">end</span>
0076 
0077 <span class="comment">% Matrix to convert Nodes to Electrodes</span>
0078 <span class="comment">% Complete electrode model for all electrodes</span>
0079 <span class="comment">%  N2E = sparse(1:n_elec, n+ (1:n_elec), 1, n_elec, n+n_elec);</span>
0080 <span class="comment">%  pp.QQ= sparse(n+n_elec,p);</span>
0081 copt.cache_obj = {fwd_model.nodes,fwd_model.elems,fwd_model.electrode};
0082 copt.fstr = <span class="string">'calculate_N2E'</span>;
0083 [N2E,cem_electrodes] = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub3" class="code" title="subfunction [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);">calculate_N2E</a>,{fwd_model, bdy, n_elec, n}, copt);
0084 
0085 <span class="keyword">if</span> p&gt;0
0086   stim = fwd_model.stimulation;
0087   [pp.QQ, pp.VV, pp.n_meas] = <a href="#_sub5" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(N2E, stim, p);
0088 <span class="keyword">end</span>
0089 
0090 <span class="comment">% pack into a parameter return list</span>
0091 pp.n_elem   = e;
0092 pp.n_elec   = n_elec;
0093 pp.n_node   = n;
0094 pp.n_stim   = p;
0095 pp.n_dims   = d-1;
0096 pp.N2E      = N2E;
0097 pp.boundary = bdy;
0098 pp.normalize = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(fwd_model);
0099 
0100 
0101 <span class="comment">% calculate element volume and surface area</span>
0102 <a name="_sub2" href="#_subfunctions" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a>
0103    VOLUME=zeros(e,1);
0104    ones_d = ones(1,d);
0105    d1fac = prod( 1:d-1 );
0106    <span class="keyword">if</span> d &gt; size(NODE,1)
0107       <span class="keyword">for</span> i=1:e
0108           this_elem = NODE(:,ELEM(:,i)); 
0109           VOLUME(i)= abs(det([ones_d;this_elem])) / d1fac;
0110       <span class="keyword">end</span>
0111    <span class="keyword">elseif</span> d == 3 <span class="comment">% 3D nodes in 2D mesh</span>
0112       <span class="keyword">for</span> i=1:e
0113           this_elem = NODE(:,ELEM(:,i)); 
0114           d12= det([ones_d;this_elem([1,2],:)])^2;
0115           d13= det([ones_d;this_elem([1,3],:)])^2;
0116           d23= det([ones_d;this_elem([2,3],:)])^2;
0117           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0118       <span class="keyword">end</span>
0119    <span class="keyword">elseif</span> d == 2 <span class="comment">% 3D nodes in 1D mesh (ie resistor mesh)</span>
0120       <span class="keyword">for</span> i=1:e
0121           this_elem = NODE(:,ELEM(:,i)); 
0122           d12= det([ones_d;this_elem([1],:)])^2;
0123           d13= det([ones_d;this_elem([2],:)])^2;
0124           d23= det([ones_d;this_elem([3],:)])^2;
0125           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0126       <span class="keyword">end</span>
0127    <span class="keyword">else</span>
0128       warning(<span class="string">'mesh size not understood when calculating volumes'</span>)
0129       VOLUME = NaN;
0130    <span class="keyword">end</span>
0131 
0132 
0133 
0134 <a name="_sub3" href="#_subfunctions" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a>
0135    cem_electrodes= 0; <span class="comment">% num electrodes part of Compl. Elec Model</span>
0136    N2E = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(n_elec, n+n_elec);
0137    <span class="keyword">for</span> i=1:n_elec
0138        <span class="keyword">try</span>
0139            elec_nodes = fwd_model.electrode(i).nodes;
0140        <span class="keyword">catch</span>
0141            <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Warning: electrode %d has no nodes'</span>,i);
0142            <span class="keyword">break</span>; <span class="comment">%Not a real electrode so don't include</span>
0143        <span class="keyword">end</span>
0144        <span class="keyword">if</span> length(elec_nodes) ==1 <span class="comment">% point electrode (maybe inside body)</span>
0145           N2E(i, elec_nodes) = 1;
0146        <span class="keyword">elseif</span> length(elec_nodes) ==0
0147          error(<span class="string">'EIDORS:fwd_model_parameters:electrode'</span>,<span class="string">'zero length electrode specified'</span>);
0148        <span class="keyword">else</span>
0149           bdy_idx= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, [], elec_nodes);
0150 
0151           <span class="keyword">if</span> ~isempty(bdy_idx) <span class="comment">% CEM electrode</span>
0152              cem_electrodes = cem_electrodes+1;
0153              N2E(i, n+cem_electrodes) =1;
0154           <span class="keyword">else</span> <span class="comment">% point electrodes</span>
0155                <span class="comment">% FIXME: make current defs between point electrodes and CEMs compatible</span>
0156              [bdy_idx,srf_area]= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, <span class="keyword">...</span>
0157                             fwd_model.nodes, elec_nodes);
0158              N2E(i, elec_nodes) = srf_area/sum(srf_area);
0159           <span class="keyword">end</span>
0160        <span class="keyword">end</span>
0161    <span class="keyword">end</span>
0162    N2E = N2E(:, 1:(n+cem_electrodes));
0163 
0164 <span class="comment">% If N2E can be made a logical (0-1) matrix, do it.</span>
0165    <span class="keyword">if</span> all(N2E(find(N2E(:)))==1)
0166       N2E = logical(N2E);
0167    <span class="keyword">end</span>
0168 
0169 
0170 <a name="_sub4" href="#_subfunctions" class="code">function [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)</a>
0171    QQ = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0172    VV = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p); N2E0 = N2E&gt;0;
0173    n_meas= 0; <span class="comment">% sum total number of measurements</span>
0174    <span class="keyword">for</span> i=1:p
0175        src= zeros(size(N2E,2),1);
0176        <span class="keyword">try</span>;  src =       N2E' * stim(i).stim_pattern; <span class="keyword">end</span>
0177        <span class="keyword">try</span>;  src = src + stim(i).interior_sources;    <span class="keyword">end</span>
0178        <span class="keyword">if</span> all(size(src) == [1,1]) &amp;&amp; src==0
0179           error(<span class="string">'no stim_patterns or interior_sources provided for pattern #%d'</span>,i);
0180        <span class="keyword">end</span>
0181        
0182        QQ(:,i) = src;
0183        n_meas = n_meas + size(stim(i).meas_pattern,1);
0184 
0185        vlt= zeros(size(N2E,2),1);
0186        <span class="keyword">try</span>;  vlt =      N2E0' * stim(i).volt_pattern; <span class="keyword">end</span>
0187        VV(:,i) = vlt;
0188    <span class="keyword">end</span>
0189 
0190 <a name="_sub5" href="#_subfunctions" class="code">function [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)</a>
0191    <span class="keyword">try</span>
0192    ncols = arrayfun(@(x) size(x.stim_pattern,2), stim);
0193    <span class="keyword">end</span>
0194    <span class="keyword">if</span> any(ncols&gt;1);
0195       str = <span class="string">'multiple columns in stim_pattern for patterns: '</span>;
0196       error(<span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>, <span class="keyword">...</span>
0197             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0198    <span class="keyword">end</span>
0199    idx = 1:p; idx(ncols==0)= [];
0200 
0201    QQ = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0202    <span class="keyword">try</span>
0203    QQ(:,idx) = N2E' * horzcat( stim(:).stim_pattern );
0204    <span class="keyword">end</span>
0205    VV = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0206    <span class="comment">% For voltages, we just need to know which N2E, not the size</span>
0207 
0208 
0209 
0210    <span class="keyword">try</span>
0211    ncols = arrayfun(@(x) size(x.volt_pattern,2), stim);
0212    <span class="keyword">end</span>
0213    <span class="keyword">if</span> any(ncols&gt;1);
0214       str = <span class="string">'multiple columns in volt_pattern for patterns: '</span>;
0215       error(<span class="string">'EIDORS:fwd_model_parameters:volt_pattern'</span>, <span class="keyword">...</span>
0216             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0217    <span class="keyword">end</span>
0218    idx = 1:p; idx(ncols==0)= [];
0219 
0220    <span class="keyword">try</span>
0221    VV(:,idx) = (N2E&gt;0)' * horzcat( stim(:).volt_pattern );
0222    <span class="keyword">end</span>
0223 
0224    n_meas = size(vertcat(stim(:).meas_pattern),1);
0225 
0226 
0227 
0228 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0229    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,16); fmdl = imdl.fwd_model;
0230    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(fmdl);
0231    [QQ1, VV1, n1m] = <a href="#_sub4" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)">calc_QQ_slow</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0232    [QQ2, VV2, n2m] = <a href="#_sub5" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0233    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_QQ'</span>, norm(QQ1-QQ2,<span class="string">'fro'</span>) + norm(n1m-n2m), 0, 1e-15);
0234    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_VV1'</span>, norm(VV1,<span class="string">'fro'</span>), 0, 1e-15);
0235    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_VV2'</span>, norm(VV2,<span class="string">'fro'</span>), 0, 1e-15);
0236 
0237    <span class="keyword">for</span> i=1:5;
0238       imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2C0'</span>,4); fmdl = imdl.fwd_model;
0239       <span class="keyword">switch</span> i
0240          <span class="keyword">case</span> 1; fmdl.stimulation(3).stim_pattern = fmdl.stimulation(3).stim_pattern*[1,2]; 
0241                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>;
0242          <span class="keyword">case</span> 2; fmdl.stimulation(1).stim_pattern = [];
0243                  expected_err = <span class="string">''</span>; expected = zeros(45,4);
0244                  expected(42:45,2:4) = [0,0,1;-1,0,0;1,-1,0;0,1,-1]*10;
0245                  param = <span class="string">'QQ'</span>;
0246          <span class="keyword">case</span> 3; fmdl.electrode(1).nodes = [];
0247                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:electrode'</span>;
0248          <span class="keyword">case</span> 4; fmdl.stimulation(1).volt_pattern = [zeros(3,1);6];
0249                  expected_err = <span class="string">''</span>; expected = zeros(45,4); expected(45,1) = 6;
0250                  param = <span class="string">'VV'</span>;
0251          <span class="keyword">case</span> 5; fmdl.stimulation(3).volt_pattern = [ones(4,2)];
0252                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:volt_pattern'</span>;
0253       <span class="keyword">end</span>
0254       err= <span class="string">''</span>;
0255       <span class="keyword">try</span>;  pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(fmdl);
0256       <span class="keyword">catch</span> e
0257          err= e.identifier;
0258       <span class="keyword">end</span>
0259       <span class="keyword">if</span> length(expected_err)&gt;0;
0260          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'expected error:'</span>,num2str(i)], err, expected_err);
0261       <span class="keyword">else</span>
0262          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'case:'</span>,num2str(i)], full(pp.(param)), expected);
0263       <span class="keyword">end</span>
0264    <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>