<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fix_model</title>
  <meta name="keywords" content="fix_model">
  <meta name="description" content="FIX_MODEL: Add useful fields to a model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; fix_model.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>fix_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>FIX_MODEL: Add useful fields to a model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [mdl] = fix_model(mdl,opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FIX_MODEL: Add useful fields to a model
    [mdl] = fix_model(mdl,options)
 INPUT:
    mdl - an FEM model with at least the following fields:
       .name
       .nodes
       .elem
    options - a struct with logical values specifying which fields to
        compute. Defaults to false for absent fields. 

 Run fix_model('options') to get an all-false options struct, or
 fix_model('options',true) to get an all-true one.
 mdl.faces is only replaced if necessary. mdl.boundary is never replaced.

 OUTPUT:
    mdl - a copy of the input model with these additional fields:
       .boundary
       .boundary_face
       .faces
       .face2elem
       .elem2face
       .elem_centre
       .face_centre
       .face_area
       .normals
       .max_edge_len (per elem)
       .edges
       .edge_length
       .edge2elem
       .elem2edge
       .face2edge
       .node2elem

 For triangular meshes, edges and faces are the same.

 The elems will be reordered so that all faces are counter-clockwise.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>	ELEM_DIM: dimension of elements in space (are elements in 2D or 3D space)</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>	[fwd_model] = linear_reorder(fwd_model,ccw)</li><li><a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../eidors/tools/cross3.html" class="code" title="function c = cross3(a,b)">cross3</a>	CROSS3  3D cross parallel cross product</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/graphics/matlab/mdl_slice_mesher.html" class="code" title="function [nimg out] = mdl_slice_mesher(fmdl,level,varargin)">mdl_slice_mesher</a>	MDL_SLICE_MESHER A slice of a 3D FEM as a 2D FEM</li><li><a href="../../eidors/meshing/calc_mesh_quality.html" class="code" title="function [Q mdl] = calc_mesh_quality(mdl, show)">calc_mesh_quality</a>	CALC_MESH_QUALITY Various measures of mesh quality.</li><li><a href="../../eidors/meshing/netgen/ng_mk_2d_model.html" class="code" title="function mdl = ng_mk_2d_model(varargin)">ng_mk_2d_model</a>	NG_MG_2D_MODELS create a 2D mesh with Netgen via the in2d interface</li><li><a href="GREIT3D_distribution.html" class="code" title="function [imdl,distr] = GREIT3D_distribution(fmdl, vopt)">GREIT3D_distribution</a>	GREIT3D_distribution: create target distributions for 3D GREIT</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="mk_c2f_circ_mapping.html" class="code" title="function [mapping failed] = mk_c2f_circ_mapping( mdl, xyzr );">mk_c2f_circ_mapping</a>	MK_C2F_CIRC_MAPPING: create a mapping matrix from circles/spheres to FEM</li><li><a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">mk_grid_c2f</a>	MK_GRID_C2F - calculate a coarse2fine mapping for grid coarse models.</li><li><a href="mk_tet_c2f.html" class="code" title="function [c2f] = mk_tet_c2f(fmdl, rmdl, opt)">mk_tet_c2f</a>	MK_TET_C2F - calculate a coarse2fine mapping for two tet-based models.</li><li><a href="mk_thorax_model.html" class="code" title="function out = mk_thorax_model(str, elec_pos, elec_shape, maxh)">mk_thorax_model</a>	MK_THORAX_MODEL FEM models of the thorax</li><li><a href="mk_tri2tet_c2f.html" class="code" title="function c2f = mk_tri2tet_c2f(fmdl,rmdl, opt)">mk_tri2tet_c2f</a>	MK_TRI2TET_C2F - coarse2fine mapping between tri-based and tet-based models</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</li><li><a href="place_elec_on_surf.html" class="code" title="function mdl2 = place_elec_on_surf(mdl,elec_pos, elec_spec,ng_opt_file, maxh)">place_elec_on_surf</a>	PLACE_ELEC_ON_SURF Place electrodes on the surface of a model</li><li><a href="../../eidors/solvers/inverse/prior_laplace.html" class="code" title="function Reg= prior_laplace( inv_model )">prior_laplace</a>	PRIOR_LAPLACE calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function mdl = do_fix_model(mdl, doall, opt)</a></li><li><a href="#_sub2" class="code">function inner_normal = test_inner_normal( mdl )</a></li><li><a href="#_sub3" class="code">function [faces,  elem2face] = calc_faces(mdl, facedim)</a></li><li><a href="#_sub4" class="code">function edge2elem = calc_edge2elem(elem2edge,n_edges)</a></li><li><a href="#_sub5" class="code">function f2e = calc_face2edge(mdl)</a></li><li><a href="#_sub6" class="code">function face2elem = calc_face2elem(elem2face)</a></li><li><a href="#_sub7" class="code">function elem2face = calc_elem2face(face2elem, face_per_elem)</a></li><li><a href="#_sub8" class="code">function normals = calc_normals(mdl)</a></li><li><a href="#_sub9" class="code">function A = calc_face_area(mdl)</a></li><li><a href="#_sub10" class="code">function L = calc_edge_length(mdl)</a></li><li><a href="#_sub11" class="code">function len = calc_longest_edge(elems,nodes)</a></li><li><a href="#_sub12" class="code">function out = fix_options(mdl, opt)</a></li><li><a href="#_sub13" class="code">function out = list_options(val)</a></li><li><a href="#_sub14" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [mdl] = fix_model(mdl,opt)</a>
0002 <span class="comment">% FIX_MODEL: Add useful fields to a model</span>
0003 <span class="comment">%    [mdl] = fix_model(mdl,options)</span>
0004 <span class="comment">% INPUT:</span>
0005 <span class="comment">%    mdl - an FEM model with at least the following fields:</span>
0006 <span class="comment">%       .name</span>
0007 <span class="comment">%       .nodes</span>
0008 <span class="comment">%       .elem</span>
0009 <span class="comment">%    options - a struct with logical values specifying which fields to</span>
0010 <span class="comment">%        compute. Defaults to false for absent fields.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Run fix_model('options') to get an all-false options struct, or</span>
0013 <span class="comment">% fix_model('options',true) to get an all-true one.</span>
0014 <span class="comment">% mdl.faces is only replaced if necessary. mdl.boundary is never replaced.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% OUTPUT:</span>
0017 <span class="comment">%    mdl - a copy of the input model with these additional fields:</span>
0018 <span class="comment">%       .boundary</span>
0019 <span class="comment">%       .boundary_face</span>
0020 <span class="comment">%       .faces</span>
0021 <span class="comment">%       .face2elem</span>
0022 <span class="comment">%       .elem2face</span>
0023 <span class="comment">%       .elem_centre</span>
0024 <span class="comment">%       .face_centre</span>
0025 <span class="comment">%       .face_area</span>
0026 <span class="comment">%       .normals</span>
0027 <span class="comment">%       .max_edge_len (per elem)</span>
0028 <span class="comment">%       .edges</span>
0029 <span class="comment">%       .edge_length</span>
0030 <span class="comment">%       .edge2elem</span>
0031 <span class="comment">%       .elem2edge</span>
0032 <span class="comment">%       .face2edge</span>
0033 <span class="comment">%       .node2elem</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% For triangular meshes, edges and faces are the same.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% The elems will be reordered so that all faces are counter-clockwise.</span>
0038 
0039 <span class="comment">% (C) 2011 Bartlomiej Grychtol. Licensed under GPL v2 or v3</span>
0040 <span class="comment">% $Id: fix_model.m 5361 2017-03-16 12:40:08Z bgrychtol $</span>
0041 
0042 <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub14" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0043 
0044 <span class="keyword">if</span> ischar(mdl) &amp;&amp; strcmp(mdl,<span class="string">'options'</span>); 
0045    <span class="keyword">if</span> nargin &lt; 2, opt = false; <span class="keyword">end</span>
0046    mdl = <a href="#_sub13" class="code" title="subfunction out = list_options(val)">list_options</a>(opt); 
0047    <span class="keyword">return</span> 
0048 <span class="keyword">end</span>
0049 doall = false;
0050 <span class="keyword">if</span> nargin &gt; 1
0051    opt = <a href="#_sub12" class="code" title="subfunction out = fix_options(mdl, opt)">fix_options</a>(mdl,opt);
0052 <span class="keyword">else</span>
0053    doall = true; opt=struct;
0054 <span class="keyword">end</span>
0055 
0056 <span class="comment">% prepare a model with geometry only</span>
0057 tmp.nodes = mdl.nodes;
0058 tmp.elems = mdl.elems;
0059 tmp.type  = mdl.type;
0060 <span class="keyword">try</span>, tmp.boundary = mdl.boundary; <span class="keyword">end</span>
0061 <span class="keyword">try</span>, tmp.faces = mdl.faces; <span class="keyword">end</span>
0062 
0063 copt.cache_obj = {tmp, doall, opt};
0064 copt.fstr      = <span class="string">'fix_model'</span>;
0065 
0066 tmp = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>( @<a href="#_sub1" class="code" title="subfunction mdl = do_fix_model(mdl, doall, opt)">do_fix_model</a>, {tmp, doall, opt}, copt);
0067 
0068 <span class="comment">% copy new fields to mdl</span>
0069 flds = fieldnames(tmp); flds(1:3) = []; <span class="comment">% ignore nodes, elems and type</span>
0070 <span class="keyword">for</span> i = 1:numel(flds)
0071    mdl.(flds{i}) = tmp.(flds{i});
0072 <span class="keyword">end</span>
0073 
0074 
0075 
0076 <span class="comment">% Complete the function</span>
0077 <a name="_sub1" href="#_subfunctions" class="code">function mdl = do_fix_model(mdl, doall, opt)</a>
0078 
0079 <span class="keyword">if</span> doall || opt.boundary
0080    <span class="keyword">if</span> ~isfield(mdl,<span class="string">'boundary'</span>)
0081       mdl.boundary = <a href="../../eidors/solvers/forward/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(mdl);
0082    <span class="keyword">end</span>
0083 <span class="keyword">end</span>
0084 <span class="keyword">if</span> doall || opt.faces
0085    <span class="keyword">if</span> <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) == <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl);
0086       [mdl.faces mdl.elem2face] = <a href="#_sub3" class="code" title="subfunction [faces,  elem2face] = calc_faces(mdl, facedim)">calc_faces</a>(mdl);
0087    <span class="keyword">else</span>
0088       <span class="comment">% surface mesh</span>
0089       mdl.faces = sort(mdl.elems,2);
0090       mdl.elem2face = (1:length(mdl.faces))';
0091    <span class="keyword">end</span>
0092 <span class="keyword">end</span>
0093 <span class="keyword">if</span> doall || opt.face2elem
0094     mdl.face2elem = <a href="#_sub6" class="code" title="subfunction face2elem = calc_face2elem(elem2face)">calc_face2elem</a>(mdl.elem2face);
0095 <span class="keyword">end</span>
0096 <span class="keyword">if</span> doall || opt.boundary_face
0097    mdl.boundary_face = mdl.face2elem(:,2)==0;
0098 <span class="keyword">end</span>
0099 <span class="keyword">if</span> doall || opt.elem_centre
0100    mdl.elem_centre = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl, 0);
0101 <span class="keyword">end</span>
0102 <span class="keyword">if</span> doall || opt.face_centre
0103    tmp = mdl;
0104    tmp.elems = tmp.faces;
0105    mdl.face_centre = <a href="interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(tmp,0);
0106 <span class="keyword">end</span>
0107 <span class="keyword">if</span> doall || opt.max_edge_len
0108    mdl.max_edge_len = <a href="#_sub11" class="code" title="subfunction len = calc_longest_edge(elems,nodes)">calc_longest_edge</a>(mdl.elems,mdl.nodes);
0109 <span class="keyword">end</span>
0110 <span class="keyword">if</span> doall || opt.elem_volume
0111    mdl.elem_volume = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl);
0112 <span class="keyword">end</span>
0113 <span class="keyword">if</span> doall || opt.face_area
0114    <span class="keyword">if</span> <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) == 2
0115       mdl.face_area = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl);
0116    <span class="keyword">else</span>
0117       mdl.face_area = <a href="#_sub9" class="code" title="subfunction A = calc_face_area(mdl)">calc_face_area</a>(mdl);
0118    <span class="keyword">end</span>
0119 <span class="keyword">end</span>
0120 el_dim = <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl);
0121 <span class="keyword">if</span> doall || opt.edges
0122     <span class="keyword">if</span> <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl)==3 <span class="comment">%that's unlikely to work for higher order elements</span>
0123         [mdl.edges mdl.elem2edge] = <a href="#_sub3" class="code" title="subfunction [faces,  elem2face] = calc_faces(mdl, facedim)">calc_faces</a>(mdl,2);
0124     <span class="keyword">else</span> 
0125         mdl.edges = mdl.faces;
0126         mdl.elem2edge = mdl.elem2face;
0127     <span class="keyword">end</span>
0128 <span class="keyword">end</span>
0129 <span class="keyword">if</span> doall || opt.node2elem
0130     mdl.node2elem = <a href="#_sub4" class="code" title="subfunction edge2elem = calc_edge2elem(elem2edge,n_edges)">calc_edge2elem</a>(mdl.elems,size(mdl.nodes,1));
0131 <span class="keyword">end</span>
0132 <span class="keyword">if</span> doall || opt.edge2elem
0133     mdl.edge2elem = <a href="#_sub4" class="code" title="subfunction edge2elem = calc_edge2elem(elem2edge,n_edges)">calc_edge2elem</a>(mdl.elem2edge, size(mdl.edges,1));
0134 <span class="keyword">end</span>
0135 
0136 <span class="keyword">if</span> doall || opt.face2edge
0137    <span class="keyword">if</span> el_dim &lt;3
0138       mdl.face2edge = mdl.elem2edge;
0139    <span class="keyword">else</span>
0140       mdl.face2edge = uint32(<a href="#_sub5" class="code" title="subfunction f2e = calc_face2edge(mdl)">calc_face2edge</a>(mdl));
0141    <span class="keyword">end</span>
0142 <span class="keyword">end</span>
0143 
0144 <span class="keyword">if</span> doall || opt.edge_length
0145    mdl.edge_length = <a href="#_sub10" class="code" title="subfunction L = calc_edge_length(mdl)">calc_edge_length</a>(mdl);
0146 <span class="keyword">end</span>
0147 
0148 <span class="keyword">if</span> doall || opt.linear_reorder
0149    mdl = <a href="linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>(mdl); <span class="comment">%counter-clockwise</span>
0150 <span class="keyword">end</span>
0151 <span class="keyword">if</span> doall || opt.normals
0152    mdl.normals = <a href="#_sub8" class="code" title="subfunction normals = calc_normals(mdl)">calc_normals</a>(mdl);
0153 <span class="keyword">end</span>
0154 <span class="keyword">if</span> doall || opt.inner_normal
0155    <span class="keyword">if</span> <a href="mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl) == <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl);
0156       mdl.inner_normal = <a href="#_sub2" class="code" title="subfunction inner_normal = test_inner_normal( mdl )">test_inner_normal</a>( mdl );
0157    <span class="keyword">else</span>
0158       <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@@ Inner normal test for surface meshes not implemented.'</span>,1);
0159    <span class="keyword">end</span>
0160 <span class="keyword">end</span>
0161 
0162 <span class="comment">% decrease memory footprint</span>
0163 mdl.elems = uint32(mdl.elems);
0164 <span class="keyword">if</span> doall || opt.faces
0165    mdl.faces = uint32(mdl.faces);
0166    mdl.elem2face = uint32(mdl.elem2face);
0167 <span class="keyword">end</span>
0168 <span class="keyword">if</span> doall || opt.face2elem
0169    mdl.face2elem = uint32(mdl.face2elem);
0170 <span class="keyword">end</span>     
0171 <span class="keyword">if</span> doall || opt.edges
0172    mdl.edges = uint32(mdl.edges);
0173    mdl.elem2edge = uint32(mdl.elem2edge);
0174 <span class="keyword">end</span>
0175 <span class="keyword">if</span> doall || opt.edge2elem
0176    mdl.edge2elem = logical(mdl.edge2elem);
0177 <span class="keyword">end</span>     
0178 
0179 <span class="comment">% Test whether normal points into or outside</span>
0180 <span class="comment">% mdl.inner_normal(i,j) = 1 if face j of elem i points in</span>
0181 <a name="_sub2" href="#_subfunctions" class="code">function inner_normal = test_inner_normal( mdl )</a>
0182    inner_normal = false(size(mdl.elem2face));
0183    d = <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) + 1;
0184    <span class="keyword">for</span> i=1:<a href="num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(mdl);
0185       el_faces = mdl.elem2face(i,:);
0186       el_ctr   = repmat( mdl.elem_centre(i,:), d, 1);
0187       vec_fa_el= el_ctr -  mdl.face_centre(el_faces,:);
0188       normal_i  = mdl.normals(el_faces,:);
0189       dot_prod = sum( normal_i.*vec_fa_el, 2 );
0190       inner_normal(i,:) = dot_prod' &gt; 0;
0191    <span class="keyword">end</span>
0192 
0193 <a name="_sub3" href="#_subfunctions" class="code">function [faces,  elem2face] = calc_faces(mdl, facedim)</a>
0194 
0195 e_dim = <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl);
0196 <span class="keyword">if</span> nargin == 1
0197     facedim = e_dim;
0198 <span class="keyword">end</span>
0199 
0200 idx = nchoosek(1:e_dim+1, facedim);
0201 elem_sorted = sort(mdl.elems,2);
0202 [faces ib ia] = unique(reshape(elem_sorted(:,idx),[],facedim),<span class="string">'rows'</span>);
0203 elem2face = reshape(ia,[],size(idx,1));
0204 
0205 <a name="_sub4" href="#_subfunctions" class="code">function edge2elem = calc_edge2elem(elem2edge,n_edges)</a>
0206 
0207     [n_elems, el_faces] = size(elem2edge);
0208     elem2edgeno = (1:n_elems)'*ones(1,el_faces);
0209     elem2edgeno = elem2edgeno(:);
0210     elem2edge   = elem2edge(:);
0211     edge2elem = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(elem2edge,elem2edgeno,ones(size(elem2edgeno)),n_edges,n_elems);
0212 
0213 <a name="_sub5" href="#_subfunctions" class="code">function f2e = calc_face2edge(mdl)</a>
0214 <span class="comment">%faces and edges are both row-wise sorted</span>
0215 nf = length(mdl.faces);
0216 list(1:3:3*nf,:) = mdl.faces(:,1:2);
0217 list(2:3:3*nf,:) = mdl.faces(:,[1 3]);
0218 list(3:3:3*nf,:) = mdl.faces(:,2:3);
0219 [jnk f2e] = ismember(list, mdl.edges, <span class="string">'rows'</span>);
0220 f2e = reshape(f2e,3,[])';
0221 
0222 <a name="_sub6" href="#_subfunctions" class="code">function face2elem = calc_face2elem(elem2face)</a>
0223 <span class="comment">% This is easier to understand but very slow</span>
0224 <span class="comment">%     n_face = max(elem2face(:));</span>
0225 <span class="comment">%     face2elem = zeros(n_face,2);</span>
0226 <span class="comment">%     for i= 1:n_face</span>
0227 <span class="comment">%         [el jnk] = find(elem2face==i);</span>
0228 <span class="comment">%         if numel(el)==1, el(2) = 0; end</span>
0229 <span class="comment">%         face2elem(i,:) = el;</span>
0230 <span class="comment">%     end</span>
0231 <span class="comment">%     bck = face2elem; face2elem=[];</span>
0232     [n_elems, el_faces] = size(elem2face);
0233     elem2faceno = (1:n_elems)'*ones(1,el_faces);
0234     elem2faceno = elem2faceno(:);
0235     elem2face   = elem2face(:);
0236     face2elem(elem2face,2) = elem2faceno;
0237     <span class="comment">% flipping will give us the other element for shared faces</span>
0238     elem2faceno = flipud(elem2faceno);
0239     elem2face   = flipud(elem2face);
0240     face2elem(elem2face,1) = elem2faceno;
0241     <span class="comment">% replace with zeros repeated entries (boundary faces)</span>
0242     face2elem( face2elem(:,1) == face2elem(:,2), 2) = 0;
0243 
0244 <span class="comment">% This function is obsolete</span>
0245 <a name="_sub7" href="#_subfunctions" class="code">function elem2face = calc_elem2face(face2elem, face_per_elem)</a>
0246     n_elem = max(face2elem(:));
0247     elem2face = zeros(n_elem,face_per_elem);
0248     <span class="keyword">for</span> i = 1:n_elem
0249         [f jnk] = find(face2elem==i);
0250         elem2face(i,:) = f;
0251     <span class="keyword">end</span>
0252     
0253 <a name="_sub8" href="#_subfunctions" class="code">function normals = calc_normals(mdl)</a>
0254     [n_faces face_dim] = size(mdl.faces);
0255     <span class="keyword">switch</span> face_dim
0256         <span class="keyword">case</span> 2
0257             A = mdl.nodes(mdl.faces(:,1),:);
0258             B = mdl.nodes(mdl.faces(:,2),:);
0259             normals = (B-A)*[0 1; -1 0];
0260         <span class="keyword">case</span> 3
0261             <span class="comment">% vectorise cross product</span>
0262             x1 = mdl.nodes(mdl.faces(:,2),1) - mdl.nodes(mdl.faces(:,1),1);
0263             y1 = mdl.nodes(mdl.faces(:,2),2) - mdl.nodes(mdl.faces(:,1),2);
0264             z1 = mdl.nodes(mdl.faces(:,2),3) - mdl.nodes(mdl.faces(:,1),3);
0265             x2 = mdl.nodes(mdl.faces(:,3),1) - mdl.nodes(mdl.faces(:,1),1);
0266             y2 = mdl.nodes(mdl.faces(:,3),2) - mdl.nodes(mdl.faces(:,1),2);
0267             z2 = mdl.nodes(mdl.faces(:,3),3) - mdl.nodes(mdl.faces(:,1),3);
0268             <span class="comment">%(a2b3 ? a3b2, a3b1 ? a1b3, a1b2 ? a2b1).</span>
0269             normals = zeros(n_faces,3);
0270             normals(:,1) = y1.*z2 - z1.*y2;
0271             normals(:,2) = z1.*x2 - x1.*z2;
0272             normals(:,3) = x1.*y2 - y1.*x2;
0273         <span class="keyword">otherwise</span>;
0274             error(<span class="string">'not 2D or 3D'</span>)
0275     <span class="keyword">end</span>
0276     normals = normals./ repmat(sqrt(sum(normals.^2,2))',face_dim,1)';
0277     
0278  <a name="_sub9" href="#_subfunctions" class="code">function A = calc_face_area(mdl)</a>
0279 A = mdl.nodes(mdl.faces(:,2),:) - mdl.nodes(mdl.faces(:,1),:);
0280 B = mdl.nodes(mdl.faces(:,3),:) - mdl.nodes(mdl.faces(:,1),:);
0281 A = sqrt(sum(<a href="../../eidors/tools/cross3.html" class="code" title="function c = cross3(a,b)">cross3</a>(A,B).^2,2))/2;
0282 
0283 <a name="_sub10" href="#_subfunctions" class="code">function L = calc_edge_length(mdl)</a>
0284 L = sqrt(sum( (mdl.nodes(mdl.edges(:,1),:) <span class="keyword">...</span>
0285              - mdl.nodes(mdl.edges(:,2),:) ).^2 ,2 ));
0286     
0287 <a name="_sub11" href="#_subfunctions" class="code">function len = calc_longest_edge(elems,nodes)</a>
0288     [E_num E_dim] = size(elems);
0289 
0290     pairs = nchoosek(1:E_dim,2);
0291     len = zeros(E_num,1);
0292     <span class="keyword">for</span> i = 1:size(pairs,1)
0293         a = nodes(elems(:,pairs(i,1)),:);
0294         b = nodes(elems(:,pairs(i,2)),:);
0295         tmp = sqrt(sum((a-b).^2,2));
0296         len = max(len,tmp);  
0297     <span class="keyword">end</span>
0298     
0299 <a name="_sub12" href="#_subfunctions" class="code">function out = fix_options(mdl, opt)</a>
0300     out = <a href="#_sub13" class="code" title="subfunction out = list_options(val)">list_options</a>(false);
0301 <span class="comment">%     out.linear_reorder = 1;</span>
0302     flds = fieldnames(opt);
0303     <span class="keyword">for</span> i = 1:length(flds)
0304        <span class="keyword">try</span>
0305        out.(flds{i}) = opt.(flds{i});
0306        <span class="keyword">catch</span>
0307           warning(sprintf(<span class="string">'Option %s not recognised. Ignoring'</span>, flds{i}));
0308        <span class="keyword">end</span>
0309     <span class="keyword">end</span> 
0310     <span class="keyword">if</span> out.boundary_face
0311        out.face2elem = true;
0312     <span class="keyword">end</span>
0313     <span class="keyword">if</span> out.inner_normal
0314        out.normals = true;
0315        out.elem_centre = true;
0316        out.face_centre = true;
0317     <span class="keyword">end</span>
0318     <span class="keyword">if</span> any([ out.boundary_face out.face_centre out.normals]) &amp;&amp; ~isfield(mdl,<span class="string">'faces'</span>)
0319           out.faces = true;
0320     <span class="keyword">end</span>
0321     <span class="keyword">if</span> any([out.face2elem out.elem2face out.face_area])
0322        out.faces = true;
0323     <span class="keyword">end</span>
0324     <span class="keyword">if</span> any([out.edge2elem out.elem2edge out.edge_length out.face2edge])
0325         out.edges = true;
0326     <span class="keyword">end</span>
0327     <span class="keyword">if</span> out.edges &amp;&amp; <a href="elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) &lt; 4
0328         out.faces = true;
0329     <span class="keyword">end</span>
0330 
0331     
0332 <a name="_sub13" href="#_subfunctions" class="code">function out = list_options(val)</a>
0333     nodes = [0 0; 0 1; 1 1; 1 0];
0334     elems = [1 2 3; 1 3 4];
0335     mdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'square'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0336     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0337     out = rmfield(out,{<span class="string">'elems'</span>,<span class="string">'nodes'</span>,<span class="string">'name'</span>,<span class="string">'type'</span>});
0338     flds = fieldnames(out);
0339     <span class="keyword">for</span> i = 1:length(flds)
0340        out.(flds{i}) = val;
0341     <span class="keyword">end</span>
0342     out.linear_reorder = 0;
0343     
0344 <a name="_sub14" href="#_subfunctions" class="code">function do_unit_test</a>
0345     <span class="comment">% square</span>
0346     nodes = [0 0; 0 1; 1 1; 1 0];
0347     elems = [1 2 3; 1 3 4];
0348     mdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'square'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0349     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0350     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d: faces'</span>    ,out.faces    ,[1,2;1,3;1,4;2,3;3,4]);
0351     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d: elem2face'</span>,out.elem2face,[1,2,4;2,3,5]);
0352     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2d: face2elem'</span>,out.face2elem,[1,0;2,1;2,0;1,0;2,0]);
0353 
0354     <span class="comment">%cube</span>
0355     nodes = [0 0 0; 0 1 0; 1 1 0; 1 0 0;<span class="keyword">...</span>
0356              0 0 1; 0 1 1; 1 1 1; 1 0 1];
0357     elems = [1 2 3 6; 3 6 7 8; 1 5 6 8; 1 3 4 8; 1 3 6 8];
0358     mdl = <a href="../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'cube'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0359     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0360     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d: faces'</span>    ,out.faces(1:4,:), [1,2,3;1,2,6;1,3,4;1,3,6]);
0361     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d: elem2face'</span>,out.elem2face, [1,2,4,10; 12,13,14,16;
0362             7,8,9,15; 3,5,6,11; 4,5,9,13]);
0363     <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3d: face2elem'</span>,out.face2elem(1:5,:), [1,0; 1,0; 4,0; 5,1; 4,5]);
0364 
0365     
0366     <span class="comment">% test options</span>
0367     opt = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(<span class="string">'options'</span>,false);
0368     flds = fieldnames(opt);
0369     <span class="comment">% if there are no errors, option interdependence is dealt with</span>
0370     <span class="comment">% correctly</span>
0371     <span class="keyword">for</span> i = 1:length(flds)
0372        opt.(flds{i}) = true;
0373        out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl, opt);
0374        opt.(flds{i}) = false;
0375     <span class="keyword">end</span>
0376     
0377     mdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); mdl= mdl.fwd_model;
0378     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(mdl);
0379</pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>