<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_tri_c2f</title>
  <meta name="keywords" content="mk_tri_c2f">
  <meta name="description" content="MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">eidors</a> &gt; <a href="index.html">models</a> &gt; mk_tri_c2f.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/models&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>mk_tri_c2f
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function c2f = mk_tri_c2f(fmdl,rmdl,opt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.
 C2F = MK_TRI_C2F(FMDL,RMDL) returns in C2F the fraction of area of
 each element of the fine model FMDL contained in each element of
 the coarse model RMDL.
 Uses CONVHULLN to calculate the area defined by a set of intersection
 points between individual triangles.

 C2F = MK_TRI_C2F(FMDL,RMDL,OPT) allows specifying options.
 
 Inputs:
   FMDL - a (fine) EIDORS (tet-based) forward model
   RMDL - a (course) EIDORS (tet-based) forward model
   OPT  - an option structure with the following fields and defaults:
      .do_not_scale  - set to true to prevent scaling the models to unit
                       square before any calculations, including 
                       thresholds. Default: false
      .tol_node2tri  - minimum value of a barycentric coordinate to 
                       decide a point is lying inside a triangle and not
                       on its edge. Default: eps

 NOTE that for grid-based models, such as returned by MK_GRID_MODEL or
 MK_VOXEL_VOLUME, MK_GRID_C2F is much faster.

 Set eidors_msg 'log level' &lt; 2 to supress output to command line.

 Examples:
     fmdl = ng_mk_cyl_models([0,2,.2],[],[]);
     rmdl = ng_mk_cyl_models([0,2],[],[]);
     c2f  = mk_tri_c2f(fmdl,rmdl);
     h = show_fem(fmdl); set(h,'LineWidth',0.1,'FaceColor','none')
     hold on
     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2,...
        'FaceColor','none');
     hold off

 See also <a href="mk_grid_c2f.html" class="code" title="function [c2f, m] = mk_grid_c2f(fmdl, rmdl, opt)">MK_GRID_C2F</a>, <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">FIND_EDGE2EDGE_INTERSECTIONS</a>, CONVHULLN
          <a href="mk_approx_c2f.html" class="code" title="function [mapping, outside] = mk_approx_c2f( f_mdl, c_mdl );">MK_APPROX_C2F</a>, <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">POINT_IN_TRIANGLE</a>, EIDORS_MSG</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>	FIND_EDGE2EDGE_INTERSECTIONS intersections between edges of two models</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</li><li><a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>	POINT_IN_TRIANGLE tests points for membership in triangles</li><li><a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../eidors/overloads/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>	C = uniquetol(A,TOL):  unique values in A using tolerance TOL.</li><li><a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>	EIDORS_DEBUG Global managment of debug flags</li><li><a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>	PROGRESS_MSG Progress messages and timing.</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="mk_analytic_c2f.html" class="code" title="function [mapping, outside] = mk_analytic_c2f( f_mdl, c_mdl, opt)">mk_analytic_c2f</a>	MK_ANALYTIC_C2F: create a mapping matrix from coarse to fine FEM</li><li><a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>	MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function c2f = do_mk_tri_c2f(fmdl,rmdl,opt)</a></li><li><a href="#_sub2" class="code">function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN)</a></li><li><a href="#_sub3" class="code">function fmdl = prepare_tri_mdl(fmdl)</a></li><li><a href="#_sub4" class="code">function [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)</a></li><li><a href="#_sub5" class="code">function[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a></li><li><a href="#_sub6" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li><li><a href="#_sub8" class="code">function do_small_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function c2f = mk_tri_c2f(fmdl,rmdl,opt)</a>
0002 <span class="comment">%MK_TRI_C2F - calculate a coarse2fine mapping for triangle-based models.</span>
0003 <span class="comment">% C2F = MK_TRI_C2F(FMDL,RMDL) returns in C2F the fraction of area of</span>
0004 <span class="comment">% each element of the fine model FMDL contained in each element of</span>
0005 <span class="comment">% the coarse model RMDL.</span>
0006 <span class="comment">% Uses CONVHULLN to calculate the area defined by a set of intersection</span>
0007 <span class="comment">% points between individual triangles.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% C2F = MK_TRI_C2F(FMDL,RMDL,OPT) allows specifying options.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% Inputs:</span>
0012 <span class="comment">%   FMDL - a (fine) EIDORS (tet-based) forward model</span>
0013 <span class="comment">%   RMDL - a (course) EIDORS (tet-based) forward model</span>
0014 <span class="comment">%   OPT  - an option structure with the following fields and defaults:</span>
0015 <span class="comment">%      .do_not_scale  - set to true to prevent scaling the models to unit</span>
0016 <span class="comment">%                       square before any calculations, including</span>
0017 <span class="comment">%                       thresholds. Default: false</span>
0018 <span class="comment">%      .tol_node2tri  - minimum value of a barycentric coordinate to</span>
0019 <span class="comment">%                       decide a point is lying inside a triangle and not</span>
0020 <span class="comment">%                       on its edge. Default: eps</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% NOTE that for grid-based models, such as returned by MK_GRID_MODEL or</span>
0023 <span class="comment">% MK_VOXEL_VOLUME, MK_GRID_C2F is much faster.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% Set eidors_msg 'log level' &lt; 2 to supress output to command line.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% Examples:</span>
0028 <span class="comment">%     fmdl = ng_mk_cyl_models([0,2,.2],[],[]);</span>
0029 <span class="comment">%     rmdl = ng_mk_cyl_models([0,2],[],[]);</span>
0030 <span class="comment">%     c2f  = mk_tri_c2f(fmdl,rmdl);</span>
0031 <span class="comment">%     h = show_fem(fmdl); set(h,'LineWidth',0.1,'FaceColor','none')</span>
0032 <span class="comment">%     hold on</span>
0033 <span class="comment">%     h = show_fem(rmdl); set(h,'EdgeColor','b','LineWidth',2,...</span>
0034 <span class="comment">%        'FaceColor','none');</span>
0035 <span class="comment">%     hold off</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% See also MK_GRID_C2F, FIND_EDGE2EDGE_INTERSECTIONS, CONVHULLN</span>
0038 <span class="comment">%          MK_APPROX_C2F, POINT_IN_TRIANGLE, EIDORS_MSG</span>
0039 
0040 <span class="comment">% (C) 2015 Bartlomiej Grychtol</span>
0041 <span class="comment">% License: GPL version 2 or 3</span>
0042 <span class="comment">% $Id: mk_tri_c2f.m 5068 2015-05-30 12:07:52Z bgrychtol $</span>
0043 
0044 
0045 <span class="keyword">if</span> ischar(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>), <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0046 <span class="keyword">if</span> nargin &lt; 3
0047    opt = struct();
0048 <span class="keyword">end</span>
0049 
0050 f_elems = size(fmdl.elems,1);
0051 r_elems = size(rmdl.elems,1);
0052 
0053 c2f = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(f_elems,r_elems);
0054 [fmdl,rmdl,fmdl_idx,rmdl_idx] = <a href="#_sub4" class="code" title="subfunction [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)">crop_models</a>(fmdl,rmdl);
0055 
0056 <span class="keyword">if</span> ~(any(fmdl_idx) &amp;&amp; any(rmdl_idx))
0057    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@: models do not overlap, returning all-zeros'</span>);
0058    <span class="keyword">return</span>
0059 <span class="keyword">end</span>
0060 
0061 [fmdl,rmdl] = <a href="#_sub5" class="code" title="subfunction[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)">center_scale_models</a>(fmdl,rmdl, opt);
0062 
0063 opt = <a href="#_sub6" class="code" title="subfunction opt = parse_opts(fmdl,rmdl, opt)">parse_opts</a>(fmdl,rmdl, opt);
0064 
0065 
0066 copt.fstr = <span class="string">'mk_tri_c2f'</span>;
0067 
0068 c2f(fmdl_idx,rmdl_idx) = <a href="../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction c2f = do_mk_tri_c2f(fmdl,rmdl,opt)">do_mk_tri_c2f</a>,{fmdl,rmdl,opt},copt);
0069 <span class="keyword">end</span>
0070 
0071 <a name="_sub1" href="#_subfunctions" class="code">function c2f = do_mk_tri_c2f(fmdl,rmdl,opt)</a>
0072    DEBUG = <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_tri_c2f'</span>);
0073    
0074    c2f = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(0,0);
0075    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare fine model...'</span>);
0076    fmdl = <a href="#_sub3" class="code" title="subfunction fmdl = prepare_tri_mdl(fmdl)">prepare_tri_mdl</a>(fmdl);
0077    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0078    
0079    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Prepare course model...'</span>);
0080    rmdl = <a href="#_sub3" class="code" title="subfunction fmdl = prepare_tri_mdl(fmdl)">prepare_tri_mdl</a>(rmdl);
0081    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0082    
0083    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find edge2edge intersections...'</span>);
0084    [intpts,fedge2redge,fedge2intpts,redge2intpts] = <span class="keyword">...</span>
0085       <a href="find_edge2edge_intersections.html" class="code" title="function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN, epsilon)">find_edge2edge_intersections</a>( fmdl.edges,fmdl.nodes,<span class="keyword">...</span>
0086                                     rmdl.edges,rmdl.nodes);
0087    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,size(intpts,1)),Inf);
0088 
0089    
0090    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_nodes in f_elems...'</span>);
0091    rnode2ftri = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(rmdl.nodes, fmdl.elems, fmdl.nodes, opt.tol_node2tri);
0092    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(rnode2ftri)), Inf);
0093    
0094    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find c_elems in f_elems...'</span>)
0095    rtri_in_ftri = (double(rmdl.node2elem') * rnode2ftri) == 3;
0096    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(rtri_in_ftri)), Inf);
0097    
0098    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_nodes in c_elems...'</span>);
0099    fnode2rtri = <a href="point_in_triangle.html" class="code" title="function out = point_in_triangle(P,E,V,epsilon, str)">point_in_triangle</a>(fmdl.nodes, rmdl.elems, rmdl.nodes, opt.tol_node2tri);
0100    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>, nnz(fnode2rtri)), Inf);
0101    
0102    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find f_elems in c_elems...'</span>)
0103    ftri_in_rtri = (double(fmdl.node2elem') * fnode2rtri) == 3;
0104    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(ftri_in_rtri)), Inf);
0105 
0106    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Find total intersections...'</span>);
0107    rtri2ftri = double(rmdl.edge2elem') * fedge2redge' * fmdl.edge2elem;
0108    <span class="comment">% exclude inclusion (dealt with separately)</span>
0109    rtri2ftri = rtri2ftri &amp; ~rtri_in_ftri &amp; ~ftri_in_rtri'; 
0110    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(sprintf(<span class="string">'Found %d'</span>,nnz(rtri2ftri)), Inf);
0111    
0112    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(<span class="string">'Calculate intersection volumes...'</span>);
0113    <span class="comment">% sparse logical multiplication doesn't exist</span>
0114    rtri2intpt = logical(rmdl.edge2elem'*redge2intpts)';
0115    ftri2intpt = logical(fmdl.edge2elem'*fedge2intpts)';
0116    
0117    rtri_todo = find(sum(rtri2ftri,2)&gt;0);
0118    C = []; F = []; V = [];
0119 
0120    id = 0; N = length(rtri_todo);
0121    mint = ceil(N/100);
0122    <span class="keyword">for</span> v = rtri_todo'
0123       id = id+1;
0124       <span class="keyword">if</span> mod(id,mint)==0, <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(id/N); <span class="keyword">end</span>
0125       tri_todo = find(rtri2ftri(v,:));
0126 
0127       common_intpts = bsxfun(@and,rtri2intpt(:,v), ftri2intpt(:,tri_todo));
0128       
0129       f_nodes     = bsxfun(@and,fnode2rtri(:,v), fmdl.node2elem(:,tri_todo));
0130       r_nodes     = bsxfun(@and,rnode2ftri(:,tri_todo), rmdl.node2elem(:,v));
0131       
0132       C = [C; v*ones(numel(tri_todo),1)];
0133       F = [F; tri_todo'];
0134       last_v = numel(V);
0135       V = [V; zeros(numel(tri_todo),1)]; <span class="comment">% pre-allocate</span>
0136       
0137       <span class="keyword">for</span> t = 1:numel(tri_todo)
0138          pts = [ intpts(common_intpts(:,t),:);
0139                   fmdl.nodes(f_nodes(:,t),:);
0140                   rmdl.nodes(r_nodes(:,t),:)];
0141          last_v = last_v + 1;
0142          <span class="keyword">if</span> size(pts,1) &lt; 3, <span class="keyword">continue</span>, <span class="keyword">end</span> 
0143          <span class="keyword">try</span>
0144             <span class="comment">% move points to origin (helps for small elements at</span>
0145             <span class="comment">% large coordinates</span>
0146             ctr = mean(pts);
0147             pts = bsxfun(@minus,pts,ctr);
0148             scale = max(abs(pts(:)));
0149             <span class="keyword">if</span> scale == 0 <span class="comment">%happens when there's only one point</span>
0150                <span class="keyword">continue</span>
0151             <span class="keyword">end</span>
0152             <span class="comment">% scale largest coordinate to 1 (helps with precision)</span>
0153             pts = pts ./ scale;
0154             <span class="comment">% force thorough search for initinal simplex and</span>
0155             <span class="comment">% supress precision warnings</span>
0156             [K, V(last_v)] = convhulln(pts,{<span class="string">'Qt Pp Qs'</span>});
0157             V(last_v) = max(V(last_v),0); <span class="comment">% numerical issues may produce tiny negative volume</span>
0158             V(last_v) = V(last_v) * scale^2; <span class="comment">% undo scaling</span>
0159          <span class="keyword">catch</span> err
0160             ok = false;
0161             <span class="keyword">switch</span> err.identifier
0162                <span class="keyword">case</span> {<span class="string">'MATLAB:qhullmx:DegenerateData'</span>, <span class="string">'MATLAB:qhullmx:UndefinedError'</span>}
0163                   <span class="comment">% border case point may be included multiple times.</span>
0164                   <span class="comment">% this is OK... though we may miss cases where more</span>
0165                   <span class="comment">% points should have been found but were not</span>
0166                   u = <a href="../../eidors/overloads/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>(pts*scale,1e-14,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>, 1);
0167                   ok = ok | (size(u,1) &lt; 3);
0168                   <span class="keyword">if</span> ~ok
0169                      <span class="comment">% test for colinearity</span>
0170                      cp = bsxfun(@minus, u(2:<span class="keyword">end</span>,:), u(1,:));
0171                      l = sqrt(sum(cp.^2,2));
0172                      cp = bsxfun(@rdivide, cp, l);
0173                      u = <a href="../../eidors/overloads/uniquetol.html" class="code" title="function out = uniquetol(in, tol, varargin)">uniquetol</a>(cp,1e-14,<span class="string">'ByRows'</span>,true,<span class="string">'DataScale'</span>,1);
0174                      ok = ok | size(u,1) == 1; <span class="comment">% co-linear points</span>
0175                   <span class="keyword">end</span>
0176             <span class="keyword">end</span>
0177             <span class="keyword">if</span> ~ok
0178                <span class="keyword">if</span> DEBUG || <a href="../../eidors/tools/eidors_debug.html" class="code" title="function out = eidors_debug(command, fstr)">eidors_debug</a>(<span class="string">'query'</span>,<span class="string">'mk_tet_c2f:convhulln'</span>);
0179                   tri.nodes = fmdl.nodes;
0180                   vox.nodes = rmdl.nodes;
0181                   tri.type = <span class="string">'fwd_model'</span>;
0182                   vox.type = <span class="string">'fwd_model'</span>;
0183                   vox.elems = rmdl.elems(v,:);
0184                   vox.boundary = vox.elems;
0185                   tri.elems = fmdl.elems(tri_todo(t),:);
0186                   clf
0187                   <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(vox)
0188                   hold on
0189                   h = <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(tri);
0190                   set(h,<span class="string">'EdgeColor'</span>,<span class="string">'b'</span>)
0191                   pts = bsxfun(@plus,pts*scale,ctr);
0192                   plot(pts(:,1),pts(:,2),<span class="string">'o'</span>);
0193                   hold off
0194                   axis auto
0195                   keyboard
0196                <span class="keyword">else</span>
0197                   fprintf(<span class="string">'\n'</span>);
0198                   <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'convhulln has thrown an error. '</span> <span class="keyword">...</span>
0199                      <span class="string">'Enable eidors_debug on mk_tri_c2f and re-run to see a debug plot'</span>],0);
0200                   rethrow(err);
0201                <span class="keyword">end</span>
0202             <span class="keyword">end</span>
0203          <span class="keyword">end</span>
0204          
0205       <span class="keyword">end</span>
0206    <span class="keyword">end</span>
0207    <a href="../../eidors/tools/progress_msg.html" class="code" title="function progress_msg(varargin)">progress_msg</a>(Inf);
0208    
0209    c2f = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(F,C,V,size(fmdl.elems,1),size(rmdl.elems,1));
0210    
0211    <span class="comment">% add rtri contained in ftri</span>
0212    <span class="keyword">try</span> rmdl = rmfield(rmdl,<span class="string">'coarse2fine'</span>); <span class="keyword">end</span> <span class="comment">% messes with volume</span>
0213    c2f = c2f + bsxfun(@times, <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(rtri_in_ftri), <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl))';
0214    
0215    <span class="comment">% normalize to fine volume</span>
0216    vol = <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl);
0217    c2f = bsxfun(@rdivide,c2f,vol);
0218    
0219    <span class="comment">% count identical triangles just once</span>
0220    ftri_in_rtri(rtri_in_ftri') = 0;
0221    
0222    <span class="comment">% add fine elems contained in coarse elems</span>
0223    c2f = c2f + ftri_in_rtri;
0224 
0225 <span class="keyword">end</span>
0226 
0227 
0228 <a name="_sub2" href="#_subfunctions" class="code">function [pts,FE2CE,FE2pts,CE2pts] = find_edge2edge_intersections(FE,FN,CE,CN)</a>
0229    P1 = FN(FE(:,1),:);
0230    P2 = FN(FE(:,2),:);
0231    P3 = CN(CE(:,1),:);
0232    P4 = CN(CE(:,2),:);
0233    
0234    P21 = P2 - P1;
0235    P43 = P4 - P3;
0236    
0237    invden = ( bsxfun(@times, P21(:,1), P43(:,2)') - <span class="keyword">...</span>
0238               bsxfun(@times, P21(:,2), P43(:,1)')       ).^-1;
0239    P13_x = bsxfun(@minus,P1(:,1),P3(:,1)');
0240    P13_y = bsxfun(@minus,P1(:,2),P3(:,2)');
0241    s = ( bsxfun(@times,-P21(:,2), P13_x) + <span class="keyword">...</span>
0242          bsxfun(@times, P21(:,1), P13_y)) .* invden;
0243    t = ( bsxfun(@times,-P43(:,2)',P13_x) + <span class="keyword">...</span>
0244          bsxfun(@times, P43(:,1)',P13_y)) .* invden;
0245 
0246    FE2CE= s &gt;= 0 &amp; s &lt;= 1 &amp; t &gt;= 0 &amp; t &lt;= 1;
0247    
0248    [fe, ce] = find(FE2CE);
0249    N_pts = size(fe,1);
0250    pts = zeros(N_pts,2);
0251    <span class="keyword">for</span> i = 1:N_pts
0252       pts(i,:) = P1(fe(i),:) + t(fe(i),ce(i)) * P21(fe(i),:);
0253    <span class="keyword">end</span>
0254    FE2CE = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(FE2CE);
0255    N_ce = size(CE,1);
0256    N_fe = size(FE,1);
0257    FE2pts = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(fe, 1:N_pts, ones(N_pts,1), N_fe, N_pts);
0258    CE2pts = <a href="../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(ce, 1:N_pts, ones(N_pts,1), N_ce, N_pts);
0259 
0260 
0261 <span class="keyword">end</span>
0262 
0263 <span class="comment">%-------------------------------------------------------------------------%</span>
0264 <span class="comment">% Prepare model</span>
0265 <a name="_sub3" href="#_subfunctions" class="code">function fmdl = prepare_tri_mdl(fmdl)</a>
0266    fmopt.elem2edge = true;
0267    fmopt.edge2elem = true;
0268 <span class="comment">%    fmopt.face2elem = true;</span>
0269    fmopt.node2elem = true;
0270 <span class="comment">%    fmopt.normals   = true;</span>
0271    fmopt.linear_reorder = false; <span class="comment">% this is slow and not needed</span>
0272    ll = <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,1);
0273    fmdl = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,opt)">fix_model</a>(fmdl,fmopt);
0274    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'log_level'</span>,ll);
0275    fmdl.node2elem = logical(fmdl.node2elem);
0276 
0277 <span class="keyword">end</span>
0278 
0279 <span class="comment">%-------------------------------------------------------------------------%</span>
0280 <span class="comment">% Remove obviously non-overlapping parts of the models</span>
0281 <a name="_sub4" href="#_subfunctions" class="code">function [fmdl,rmdl,fmdl_idx,rmdl_idx] = crop_models(fmdl,rmdl)</a>
0282 
0283 <span class="comment">% instead of the usual approach, we could calculate the convex hull and</span>
0284 <span class="comment">% then use inpolygon... but that would require trusting inpolygon</span>
0285 
0286    f_min = min(fmdl.nodes);
0287    f_max = max(fmdl.nodes);
0288    r_min = min(rmdl.nodes);
0289    r_max = max(rmdl.nodes);
0290    
0291    <span class="comment">% nodes outside the bounding box of the other model</span>
0292    f_gt  = bsxfun(@gt, fmdl.nodes, r_max);
0293    f_lt  = bsxfun(@lt, fmdl.nodes, r_min);
0294    r_gt  = bsxfun(@gt, rmdl.nodes, f_max);
0295    r_lt  = bsxfun(@lt, rmdl.nodes, f_min);
0296 
0297    <span class="comment">% elems outside the bounding box of the other model</span>
0298    re_gt = any(reshape(all(reshape(r_gt(rmdl.elems',:),3,[])),[],2),2);
0299    re_lt = any(reshape(all(reshape(r_lt(rmdl.elems',:),3,[])),[],2),2);
0300    fe_gt = any(reshape(all(reshape(f_gt(fmdl.elems',:),3,[])),[],2),2);
0301    fe_lt = any(reshape(all(reshape(f_lt(fmdl.elems',:),3,[])),[],2),2);
0302    
0303    <span class="comment">% elems to keep</span>
0304    rmdl_idx = ~(re_gt | re_lt);
0305    fmdl_idx = ~(fe_gt | fe_lt);
0306    
0307    <span class="comment">% remove non-overlapping elems</span>
0308    rmdl.elems = rmdl.elems(rmdl_idx,:);
0309    fmdl.elems = fmdl.elems(fmdl_idx,:);
0310    
0311    <span class="comment">% remove unused nodes</span>
0312    [r_used_nodes,jnk,r_n] = unique(rmdl.elems(:));
0313    [f_used_nodes,jnk,f_n] = unique(fmdl.elems(:));
0314    
0315    r_idx = 1:numel(r_used_nodes);
0316    f_idx = 1:numel(f_used_nodes);
0317    
0318    rmdl.elems = reshape(r_idx(r_n),[],3);
0319    fmdl.elems = reshape(f_idx(f_n),[],3);
0320    
0321    rmdl.nodes = rmdl.nodes(r_used_nodes,:);
0322    fmdl.nodes = fmdl.nodes(f_used_nodes,:);
0323    
0324    <span class="comment">% for the benefit of any (debug) plots later on</span>
0325    <span class="keyword">try</span>, rmdl = rmfield(rmdl,<span class="string">'boundary'</span>); <span class="keyword">end</span>
0326    <span class="keyword">try</span>, fmdl = rmfield(fmdl,<span class="string">'boundary'</span>); <span class="keyword">end</span>
0327     
0328 <span class="keyword">end</span>
0329 
0330 <span class="comment">%-------------------------------------------------------------------------%</span>
0331 <span class="comment">% Center scale models</span>
0332 <a name="_sub5" href="#_subfunctions" class="code">function[fmdl,rmdl] = center_scale_models(fmdl,rmdl, opt)</a>
0333    ctr = mean([min(rmdl.nodes);max(rmdl.nodes)]);
0334    rmdl.nodes = bsxfun(@minus,rmdl.nodes,ctr);
0335    fmdl.nodes = bsxfun(@minus,fmdl.nodes,ctr);
0336    <span class="keyword">if</span> isfield(opt,<span class="string">'do_not_scale'</span>) &amp;&amp; opt.do_not_scale
0337       <span class="keyword">return</span>
0338    <span class="keyword">end</span>
0339    maxnode = min( max(abs(rmdl.nodes(:))), max(abs(fmdl.nodes(:))));
0340    scale = 1/maxnode;
0341    rmdl.nodes = scale*rmdl.nodes;
0342    fmdl.nodes = scale*fmdl.nodes;
0343    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ models scaled by %g'</span>, scale,2);
0344 <span class="keyword">end</span>
0345 
0346 <span class="comment">%-------------------------------------------------------------------------%</span>
0347 <span class="comment">% Parse option struct</span>
0348  <a name="_sub6" href="#_subfunctions" class="code">function opt = parse_opts(fmdl,rmdl, opt)</a>
0349   
0350     <span class="keyword">if</span> ~isfield(opt, <span class="string">'tol_node2tri'</span>);
0351         opt.tol_node2tri = eps; <span class="comment">% * max(rmdl_rng,fmdl_rng)^3;</span>
0352     <span class="keyword">end</span>
0353 
0354     <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'@@ node2tri  tolerance = %g'</span>, opt.tol_node2tri,2);
0355 
0356  <span class="keyword">end</span>   
0357 
0358 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0359    <a href="#_sub8" class="code" title="subfunction do_small_test">do_small_test</a>
0360 <span class="keyword">end</span>
0361 
0362 <a name="_sub8" href="#_subfunctions" class="code">function do_small_test</a>
0363    imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c'</span>,16);
0364    rmdl = imdl.fwd_model;
0365 <span class="comment">%    rmdl = ng_mk_cyl_models([0 .5],[],[]);</span>
0366 <span class="comment">%    rmdl.nodes(:,1) = rmdl.nodes(:,1) + .5;</span>
0367 <span class="comment">%    show_fem(rmdl,[0 0 1])</span>
0368 <span class="comment">%    hold all</span>
0369    imdl = <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'d2c'</span>,16);
0370    fmdl = imdl.fwd_model;
0371 <span class="comment">%    fmdl = ng_mk_cyl_models([0 .5 .1],[],[]);</span>
0372 <span class="comment">%    h = show_fem(fmdl);</span>
0373 <span class="comment">%    set(h,'edgecolor','b','facecolor','none');</span>
0374 <span class="comment">%    hold off</span>
0375 <span class="comment">%    axis auto</span>
0376    c2f = <a href="mk_tri_c2f.html" class="code" title="function c2f = mk_tri_c2f(fmdl,rmdl,opt)">mk_tri_c2f</a>(fmdl,rmdl);
0377    
0378    
0379    clf
0380    img1 = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,0);
0381    img1.elem_data = sum(c2f,2);
0382    img1.calc_colous.ref_level = .5;
0383    img1.calc_colours.clim = .5;
0384    
0385    subplot(121)
0386    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img1);
0387    img2 = <a href="mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(rmdl,0);
0388    img2.elem_data = (c2f' * <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl)) ./ <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl);
0389    img2.calc_colous.ref_level = .5;
0390    img2.calc_colours.clim = .55;
0391    subplot(122)
0392    <a href="../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img2);
0393    
0394    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check C2F size'</span>, size(c2f),[length(fmdl.elems), length(rmdl.elems)]);
0395    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check C2F max==1'</span>, max(c2f(:)), 1);
0396    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check C2F min==0'</span>, min(c2f(:)), 0);
0397    
0398    f2c = bsxfun(@rdivide, bsxfun(@times, c2f, <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(fmdl))', <a href="get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(rmdl));
0399    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check F2C max==1'</span>, max(sum(f2c,2)), 1, 1e-15);
0400    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'Check F2C min==0'</span>, min(f2c(:)), 0);
0401 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 01-Jun-2018 15:59:55 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>